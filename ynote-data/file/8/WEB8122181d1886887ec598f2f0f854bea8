{"2":"1","3":"Ju9C-1621846617594","4":{"version":1,"incompatibleVersion":0,"fv":"0"},"5":[{"3":"3060-1621846615933","5":[{"2":"2","3":"p5PQ-1621846617594","7":[{"8":"●代理设计模式的原理:"}]}]},{"3":"UIpX-1656238450548","4":{"version":1},"5":[{"2":"2","3":"wJ2F-1656238450547","7":[{"8":"使用一个代理将对象包装起来,然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。"}]}]},{"3":"13h6-1656238450550","4":{"version":1},"5":[{"2":"2","3":"14i7-1656238450549","7":[{"8":"●之前为大家讲解过代理机制的操作，属于静态代理，特征是代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。最好可以通过一个代理类完成全部的代理功能。"}]}]},{"3":"xhXX-1656240345302","4":{"version":1,"u":"https://note.youdao.com/yws/res/19139/WEBRESOURCE38835f10f75e0a8517fa715be8ffd590","w":627,"h":239},"6":"im"},{"3":"QYYv-1656240342083","4":{"version":1},"5":[{"2":"2","3":"fKN1-1656240342082","7":[{"8":"静态代理："}]}]},{"3":"sob9-1656249132621","4":{"version":1,"sr":"https://note.youdao.com/yws/res/19145/WEBRESOURCETHUMB3a2682f521b14832b275fe25e5cd4ea5","re":"https://note.youdao.com/yws/res/19144/WEBRESOURCEda160852f8031fecdf796bc5d2b34f3a","fn":"StaticProxyTest.java","fl":1260},"6":"a"},{"3":"l93R-1656240342217","4":{"version":1},"5":[{"2":"2","3":"mLzI-1656240342216","7":[{"8":"动态代理："}]}]},{"3":"se11-1661829282377","4":{"version":1,"sr":"https://note.youdao.com/yws/res/b/WEBRESOURCETHUMB3fecad3a19454ce893a4323d7d649428","re":"https://note.youdao.com/yws/res/b/WEBRESOURCEe67421216b6839167f603935bc4e545b","fn":"ProxyTest.java","fl":3214},"6":"a"},{"3":"vfxk-1656240342308","4":{"version":1},"5":[{"2":"2","3":"wMX4-1656240342306"}]}],"title":"","__compress__":true}