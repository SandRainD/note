<?xml version="1.0" encoding="UTF-8" standalone="no"?><note xmlns="http://note.youdao.com" file-version="0" schema-version="1.0.3"><head><list id="1095-1635937250083" type="ordered"/><list id="7400-1635937348778" type="ordered"/></head><body><para><coId>3814-1635936670532</coId><text>缓存穿透</text><inline-styles><font-size><from>0</from><to>4</to><value>16</value></font-size></inline-styles><styles><align>justify</align><text-indent>1</text-indent></styles></para><para><coId>1780-1635937195034</coId><text>key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</text><inline-styles/><styles><align>justify</align><text-indent>1</text-indent></styles></para><para><coId>8884-1635937021500</coId><text>一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</text><inline-styles/><styles><align>justify</align><text-indent>1</text-indent></styles></para><image><coId>3510-1635937129087</coId><source>https://note.youdao.com/yws/res/14441/F4948815C3E94C3A84CDE2F2B884DF9F</source><text/><styles><width>620</width><height>315</height></styles></image><para><coId>7835-1635937135752</coId><text/><inline-styles/><styles><align>justify</align><text-indent>1</text-indent></styles></para><image><coId>4210-1635937135752</coId><source>https://note.youdao.com/yws/res/14443/F1823F0B39634FCBA92D2158238FE3AF</source><text/><styles><width>620</width><height>228</height></styles></image><para><coId>8359-1635937135752</coId><text>缓存击穿</text><inline-styles><bold><from>0</from><to>4</to><value>true</value></bold><font-family><from>0</from><to>4</to><value>SimHei</value></font-family><font-size><from>0</from><to>4</to><value>21</value></font-size></inline-styles><styles><align>justify</align><text-indent>1</text-indent></styles></para><para><coId>3126-1635937203796</coId><text>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</text><inline-styles/><styles><align>justify</align><text-indent>1</text-indent></styles></para><para><coId>7060-1635937233997</coId><text>（1）预先设置热门数据：在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</text><inline-styles><bold><from>0</from><to>12</to><value>true</value></bold><color><from>0</from><to>12</to><value>#ff0000</value></color></inline-styles><styles><align>justify</align><text-indent>1</text-indent></styles></para><para><coId>3288-1635937250087</coId><text>（2）实时调整：现场监控哪些数据热门，实时调整key的过期时长</text><inline-styles><bold><from>0</from><to>8</to><value>true</value></bold><color><from>0</from><to>8</to><value>#ff0000</value></color></inline-styles><styles><align>justify</align><text-indent>1</text-indent></styles></para><para><coId>8345-1635937250087</coId><text>（3）使用锁：</text><inline-styles><bold><from>0</from><to>7</to><value>true</value></bold><color><from>0</from><to>7</to><value>#ff0000</value></color></inline-styles><styles><align>justify</align><text-indent>1</text-indent></styles></para><list-item level="1" list-id="1095-1635937250083"><coId>4811-1635937250087</coId><text>就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</text><inline-styles/><styles><align>justify</align></styles></list-item><list-item level="1" list-id="1095-1635937250083"><coId>2022-1635937250087</coId><text>先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key</text><inline-styles/><styles><align>justify</align></styles></list-item><list-item level="1" list-id="1095-1635937250083"><coId>4154-1635937250087</coId><text>当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；</text><inline-styles/><styles><align>justify</align></styles></list-item><list-item level="1" list-id="1095-1635937250083"><coId>8441-1635937250087</coId><text>当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</text><inline-styles/><styles><align>justify</align></styles></list-item><image><coId>7357-1635937258281</coId><source>https://note.youdao.com/yws/res/14451/C1580CB4A95A4CD8892E07F8CBC41B22</source><text/><styles><width>448</width><height>411</height></styles></image><para><coId>7788-1635937234167</coId><text/><inline-styles/><styles><align>justify</align></styles></para><para><coId>9019-1635937267118</coId><text>缓存雪崩</text><inline-styles><bold><from>0</from><to>4</to><value>true</value></bold><font-family><from>0</from><to>4</to><value>SimHei</value></font-family><font-size><from>0</from><to>4</to><value>21</value></font-size></inline-styles><styles><align>justify</align></styles></para><para><coId>7386-1635937267273</coId><text>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</text><inline-styles/><styles><align>justify</align><text-indent>1</text-indent></styles></para><para><coId>1548-1635937287519</coId><text>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key</text><inline-styles/><styles><align>justify</align><text-indent>1</text-indent></styles></para><para><coId>1125-1635937234729</coId><text>缓存失效时的雪崩效应对底层系统的冲击非常可怕！</text><inline-styles/><styles><align>justify</align><text-indent>1</text-indent></styles></para><para><coId>6031-1635937348782</coId><text>解决方案：</text><inline-styles/><styles><align>justify</align><text-indent>1</text-indent></styles></para><list-item level="1" list-id="7400-1635937348778"><coId>5338-1635937348782</coId><text>构建多级缓存架构：nginx缓存 + redis缓存 +其他缓存（ehcache等）</text><inline-styles><bold><from>0</from><to>9</to><value>true</value></bold><color><from>0</from><to>9</to><value>#ff0000</value></color></inline-styles><styles><align>justify</align></styles></list-item><list-item level="1" list-id="7400-1635937348778"><coId>2365-1635937348782</coId><text>使用锁或队列：</text><inline-styles><bold><from>0</from><to>7</to><value>true</value></bold><color><from>0</from><to>7</to><value>#ff0000</value></color></inline-styles><styles><align>justify</align></styles></list-item><para><coId>4065-1635937348782</coId><text>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况</text><inline-styles/><styles><align>justify</align></styles></para><list-item level="1" list-id="7400-1635937348778"><coId>8871-1635937348782</coId><text>设置过期标志更新缓存：</text><inline-styles><bold><from>0</from><to>11</to><value>true</value></bold><color><from>0</from><to>11</to><value>#ff0000</value></color></inline-styles><styles><align>justify</align></styles></list-item><para><coId>4565-1635937348782</coId><text>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</text><inline-styles/><styles><align>justify</align></styles></para><list-item level="1" list-id="7400-1635937348778"><coId>5550-1635937348782</coId><text>将缓存失效时间分散开：</text><inline-styles><bold><from>0</from><to>11</to><value>true</value></bold><color><from>0</from><to>11</to><value>#ff0000</value></color></inline-styles><styles><align>justify</align></styles></list-item><para><coId>2214-1635937348782</coId><text>比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</text><inline-styles/><styles><align>justify</align></styles></para><para><coId>2358-1635937234958</coId><text/><inline-styles/><styles><align>justify</align><text-indent>1</text-indent></styles></para></body></note>