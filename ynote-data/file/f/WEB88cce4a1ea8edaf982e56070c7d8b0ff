{"2":"1","3":"Ju9C-1621846617594","4":{"version":1,"incompatibleVersion":0,"fv":"0"},"5":[{"3":"3060-1621846615933","5":[{"2":"2","3":"p5PQ-1621846617594","7":[{"8":"从MysQL的角度讲，不得不考虑一个现实问题就是磁盘l0。如果我们能让索引的数据结构尽量减少硬盘的I/o操作，所消耗的时间也就越小。可以说，"},{"8":"磁盘的 I/0操作次数","9":[{"0":"#FB8D00","2":"c"}]},{"8":"对索引的使用效率至关重要。"}]}]},{"3":"s9c9-1658474879270","4":{"version":1},"5":[{"2":"2","3":"KPg0-1658474879269","7":[{"8":"查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个G甚至更多，为了减少索引在内存的占用，数据库索引是存储在外部磁盘上的。当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载，那么MysQL衡量查询效率的标准就是磁盘Io次数。"}]}]},{"3":"UOLx-1658475078506","4":{"version":1,"l":"h3"},"5":[{"2":"2","3":"u0ez-1658475078503","7":[{"8":"全表遍历","9":[{"2":"b"},{"0":"#34495e","2":"c"},{"0":20,"2":"fs"}]}]}],"6":"h"},{"3":"Prx8-1658474795922","4":{"version":1},"5":[{"2":"2","3":"Qfe6-1658474795920","7":[{"8":"这里都懒得说了。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"808C-1658475088435","4":{"version":1,"l":"h3"},"5":[{"2":"2","3":"Al12-1658474795923","7":[{"8":"Hash结构","9":[{"0":"#34495e","2":"c"},{"2":"b"},{"0":20,"2":"fs"}]}]}],"6":"h"},{"3":"qpXD-1658475018462","4":{"version":1},"5":[{"2":"2","3":"dgwo-1658475018463","7":[{"8":"Hash本身是一个函数，又被称为散列函数，它可以帮助我们大幅提升检索数据的效率。"}]}]},{"3":"QEUu-1658475135106","4":{"version":1},"5":[{"2":"2","3":"24wa-1658475135105","7":[{"8":"Hash算法是通过某种确定性的算法（比如MD5、SHA1、SHA2、SHA3）将输入转变为输出。相同的输入永远可以得到相同的输出，假设输入内容有微小偏差，在输出中通常会有不同的结果。"}]}]},{"3":"xXmc-1658475135108","4":{"version":1},"5":[{"2":"2","3":"36UO-1658475135107","7":[{"8":"举例:如果你想要验证两个文件是否相同，那么你不需要把两份文件直接拿来比对，只需要让对方把Hash函数计算得到的结果告诉你即可，然后在本地同样对文件进行Hash 函数的运算，最后通过比较这两个Hash函数的结果是否相同，就可以知道这两个文件是否相同。"}]}]},{"3":"Af1V-1658475140604","4":{"version":1},"5":[{"2":"2","3":"BGhA-1658475140602","7":[{"8":"加速查找速度的数据结构，常见的有两类:","9":[{"2":"b"},{"0":"#CC0000","2":"c"}]}]}]},{"3":"GEq5-1658475158917","4":{"version":1},"5":[{"2":"2","3":"chs3-1658475158916","7":[{"8":"⑴树，例如平衡二叉搜索树，查询/插入/修改/删除的平均时间复杂度都是o(log2N) "}]}]},{"3":"C5Io-1658475179179","4":{"version":1},"5":[{"2":"2","3":"l5cf-1658475179176","7":[{"8":"⑵哈希，例如HashMap，查询/插入/修改/删除的平均时间复杂度都是0(1)"}]}]},{"3":"x9Sl-1658474822756","4":{"version":1,"u":"https://note.youdao.com/yws/res/21479/WEBRESOURCE22d5146934d2d6c3498fe03184201592","w":572,"h":285},"6":"im"},{"3":"B1AO-1658475290607","5":[{"2":"2","3":"IGkn-1658475290608","7":[{"8":"采用Hash进行检索效率非常高，基本上一次检索就可以找到数据，而B+树需要自顶向下依次查找，多次访问节点才能找到数据，中间需要多次I/o操作，`从效率来说 Hash 比 B+树更快。"}]}]},{"3":"2Ety-1658475308541","4":{"version":1},"5":[{"2":"2","3":"WoN7-1658475308540","7":[{"8":"在哈希的方式下，一个元素k处于h(k)中，即利用哈希函数h，根据关键字k计算出槽的位置。函数h将关键字域映射到哈希表T[o...m-1]的槽位上。"}]}]},{"3":"HOxM-1658475397960","4":{"version":1,"u":"https://note.youdao.com/yws/res/21500/WEBRESOURCE01622d235d3a308a78aa598535afb2cd","w":573,"h":200},"6":"im"},{"3":"Epj6-1658474831315","4":{"version":1},"5":[{"2":"2","3":"aSNc-1658474831316","7":[{"8":"上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"碰撞 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"，在数据库中一般采用 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"链 接法 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"来解决。在链接法中，将散列到同一槽位的元素放在一个链表中","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"3iBI-1658473496974","4":{"version":1},"5":[{"2":"2","3":"vYNC-1658473496972","7":[{"8":"Hash结构效率高，那为什么索引结构要设计成树型呢?","9":[{"0":"#CC0000","2":"c"}]}]}]},{"3":"JxM8-1658473497066","4":{"version":1},"5":[{"2":"2","3":"2uq2-1658473497064","7":[{"8":"原因1: Hash索引仅能满足(\u003d) (◇)和IN查询。如果进行范围查询，哈希型的索引，时间复杂度会退化为o(n);而树型的“有序\"特性，依然能够保持o(log2N)的高效率。"}]}]},{"3":"tFKt-1658475511251","4":{"version":1},"5":[{"2":"2","3":"bd3L-1658475511249","7":[{"8":"原因2: Hash索引还有一个缺陷，数据的存储是没有顺序的，在ORDER BY的情况下，使用Hash索引还需要对数据重新排序。"}]}]},{"3":"SfMJ-1658475511253","4":{"version":1},"5":[{"2":"2","3":"4Zke-1658475511252","7":[{"8":"原因3:对于联合索引的情况，Hash值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。"}]}]},{"3":"XUnH-1658475511255","4":{"version":1},"5":[{"2":"2","3":"LVpy-1658475511254","7":[{"8":"原因4:对于等值查询来说，通常Hash索引的效率更高，不过也存在一种情况，就是索引列的重复值如果很多，效率就会降低。这是因为遇到Hash冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字非常耗时。所以，Hash索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。"}]}]},{"3":"2dXH-1658475592649","4":{"version":1,"u":"https://note.youdao.com/yws/res/21509/WEBRESOURCE7d1adfc2aa9c9e10664b3a71b30ce9e3","w":573,"h":68},"6":"im"},{"3":"9VOe-1658473497276","4":{"version":1},"5":[{"2":"2","3":"FQ9J-1658473497274","7":[{"8":"Hash索引存在着很多限制，相比之下在数据库中B+树索引的使用面会更广，不过也有一些场景采用Hash 索引效率更高，比如在键值型(Key-value）数据库中，Redis存储的核心就是 Hash表。"}]}]},{"3":"RfuA-1658475717974","4":{"version":1},"5":[{"2":"2","3":"gFYU-1658475717972","7":[{"8":"MysQL中的Memory存储引擎支持Hash存储，如果我们需要用到查询的临时表时，就可以选择Memory存储引擎，把某个字段设置为Hash 索引，比如字符串类型的字段，进行Hash计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行等值查询的时候，采用Hash索引是个不错的选择。"}]}]},{"3":"eIYE-1658475716124","4":{"version":1},"5":[{"2":"2","3":"LKBw-1658475716122","7":[{"8":"另外，InnoDB本身不支持 Hash索引，但是提供自适应 Hash索引(Adaptive Hash Index)。什么情况下才会使用自适应Hash索引呢?如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到Hash表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样让B+树也具备了Hash 索引的优点。"}]}]},{"3":"w9vP-1658475080670","4":{"version":1},"5":[{"2":"2","3":"tQXm-1658475080668","7":[{"8":"采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时候，通过自适应 Hash 索引可以明显提高数据的检索效率。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"GjF3-1658475805017","4":{"version":1},"5":[{"2":"2","3":"Spbd-1658475805016","7":[{"8":"我们可以通过 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"innodb_adaptive_hash_index ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"变量来查看是否开启了自适应 Hash，比如：","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"A5rE-1658475815637","4":{"wrap":false,"la":"","th":"default"},"5":[{"3":"yDEc-1658475815635","5":[{"2":"2","3":"oIo9-1658475081190","7":[{"8":"mysql\u003e show variables like \u0027%adaptive_hash_index\u0027;"}]}],"6":"cl"}],"6":"cd"},{"3":"iant-1658475861818","4":{"l":"h3"},"5":[{"2":"2","3":"VSHs-1658475861817","7":[{"8":"二叉搜索树","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"8fhm-1658475081384","4":{"version":1},"5":[{"2":"2","3":"R3rp-1658475081382","7":[{"8":"如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"olUq-1658475081488","4":{"version":1},"5":[{"2":"2","3":"VlRp-1658475081487","7":[{"8":"1. ","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"二叉搜索树的特点","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"g7ZT-1658475897974","4":{"li":"NBCL-1658475905491","lt":"unordered","ll":1},"5":[{"2":"2","3":"ezuZ-1658475897971","7":[{"8":"一个节点只能有两个子节点，也就是一个节点度不能超过2"}]}],"6":"l"},{"3":"8BsR-1658475901140","4":{"li":"NBCL-1658475905491","lt":"unordered","ll":1},"5":[{"2":"2","3":"bSAa-1658475901138","7":[{"8":"左子节点\u003c本节点;右子节点\u003e\u003d本节点，比我大的向右，比我小的向左"}]}],"6":"l"},{"3":"AjkM-1658475879059","4":{"version":1},"5":[{"2":"2","3":"ZaoQ-1658475879058","7":[{"8":"2. ","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"查找规则","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"nClE-1658475081583","4":{"version":1},"5":[{"2":"2","3":"uhG0-1658475081581","7":[{"8":"我们先来看下最基础的二叉搜索树(Binary Search Tree)，搜索某个节点和插入节点的规则一样我们假设搜索插入的数值为key:"}]}]},{"3":"q2GR-1658480133381","4":{"version":1},"5":[{"2":"2","3":"HAA5-1658480133380","7":[{"8":"1． 如果key大于根节点，则在右子树中进行查找;"}]}]},{"3":"5ymO-1658480140933","4":{"version":1},"5":[{"2":"2","3":"cDMY-1658480140930","7":[{"8":"2．如果key 小于根节点，则在左子树中进行查找;"}]}]},{"3":"iPsn-1658480133384","4":{"version":1},"5":[{"2":"2","3":"bY89-1658480133383","7":[{"8":"3．如果key等于根节点，也就是找到了这个节点，返回根节点即可。"}]}]},{"3":"ENnx-1658480133386","4":{"version":1},"5":[{"2":"2","3":"oGNn-1658480133385","7":[{"8":"举个例子，我们对数列(34，22，89，5，23，77，91）创造出来的二分查找树如下图所示:"}]}]},{"3":"bByw-1658480151447","4":{"version":1,"u":"https://note.youdao.com/yws/res/21522/WEBRESOURCEff6de71ebe5da22ab202850de700a611","w":174,"h":130},"6":"im"},{"3":"Woo2-1658475081791","4":{"version":1},"5":[{"2":"2","3":"DGMt-1658475081790","7":[{"8":"创造出来的二分搜索树如下图所示：","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"sr1Y-1658480168453","4":{"version":1,"u":"https://note.youdao.com/yws/res/21525/WEBRESOURCEb28790155fa86b69165f01ae72d6f070","w":249,"h":283},"6":"im"},{"3":"1pT5-1658475081979","4":{"version":1},"5":[{"2":"2","3":"fA0T-1658475081977","7":[{"8":"上面第二棵树也属于二分查找树，但是性能上已经退化成了一条链表，查找数据的时间复杂度变成了0(n)。你能看出来第一个树的深度是3，也就是说最多只需3次比较，就可以找到节点，而第二个树的深度是7，最多需要7次比较才能找到节点。"}]}]},{"3":"NIre-1658480244627","4":{"version":1},"5":[{"2":"2","3":"T58A-1658480244625","7":[{"8":"为了提高查询效率，就需要 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"减少磁盘","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"IO","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"数 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"。为了减少磁盘IO的次数，就需要尽量 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"降低树的高度 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"Aizy-1658480182567","4":{"l":"h3"},"5":[{"2":"2","3":"kczn-1658480182565","7":[{"8":"AVL","9":[{"0":"#34495e","2":"c"}]},{"8":"树","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"7Frr-1658480183071","4":{"version":1},"5":[{"2":"2","3":"X4aW-1658480183070","7":[{"8":"为了解决上面二叉查找树退化成链表的问题，人们提出了平衡二叉搜索树(Balanced Binary Tree)，又称为AVL树(有别于AVL算法)，它在二叉搜索树的基础上增加了约束，具有以下性质:"}]}]},{"3":"NN0s-1658480323958","4":{"version":1},"5":[{"2":"2","3":"7qIJ-1658480323957","7":[{"8":"它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。","9":[{"0":"#CC0000","2":"c"}]}]}]},{"3":"RfKt-1658480323960","4":{"version":1},"5":[{"2":"2","3":"jYeQ-1658480323959","7":[{"8":"这里说一下，常见的平衡二叉树有很多种，包括了平衡二叉搜索树、红黑树、数堆、伸展树。平衡二叉搜索树是最早提出来的自平衡二叉搜索树，当我们提到平衡二叉树时一般指的就是平衡二叉搜索树。事实上，第一棵树就属于平衡二叉搜索树，搜索时间复杂度就是o( log2n)。"}]}]},{"3":"pVzH-1658480323962","4":{"version":1},"5":[{"2":"2","3":"PMYm-1658480323961","7":[{"8":"数据查询的时间主要依赖于磁盘Ⅳ/o的次数，如果我们采用二叉树的形式，即使通过平衡二叉搜索树进行了改进，树的深度也是 o(log2n)，当n 比较大时，深度也是比较高的，比如下图的情况:"}]}]},{"3":"VMMT-1658480360650","4":{"version":1,"u":"https://note.youdao.com/yws/res/21533/WEBRESOURCE32e7c943281e024210ac19482160dc96","w":573,"h":212},"6":"im"},{"3":"3wE2-1658480183258","4":{"version":1},"5":[{"2":"2","3":"yVMP-1658480183257","7":[{"8":"每访问一次节点就需要进行一次磁盘Ⅰ/0操作，对于上面的树来说，我们需要进行5次I/O操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘I/o操作次数多，会影响整体数据查询的效率。"}]}]},{"3":"Ehnw-1658480427341","4":{"version":1},"5":[{"2":"2","3":"l1ai-1658480427340","7":[{"8":"针对同样的数据，如果我们把二叉树改成M叉树(M\u003e2）呢?当M\u003d3时，同样的五1个节点可以由下面的三叉树来进行存储:"}]}]},{"3":"4qc7-1658480440607","4":{"version":1,"u":"https://note.youdao.com/yws/res/21536/WEBRESOURCE2b1e6c278b3720b5bf43f4937b3860ae","w":573,"h":164},"6":"im"},{"3":"A932-1658480183565","4":{"version":1},"5":[{"2":"2","3":"FQEG-1658480183564","7":[{"8":"你能看到此时树的高度降低了，当数据量N大的时候，以及树的分叉数M大的时候，M叉树的高度会远小于二叉树的高度(M \u003e2)。所以，我们需要把树从“瘦高\"变\"矮胖”。"}]}]},{"3":"hUqS-1658480480522","4":{"l":"h3"},"5":[{"2":"2","3":"QVZ1-1658480480521","7":[{"8":"B-Tree ","9":[{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"rCcf-1658480183782","4":{"version":1},"5":[{"2":"2","3":"uLr6-1658480183779","7":[{"8":"B树的英文是Balance Tree，也就是多路平衡查找树。简写为B-Tree(注意横杠表示这两个单词连起来的意思，不是减号)。它的高度远小于平衡二叉树的高度。"}]}]},{"3":"VNWB-1658480545617","4":{"version":1,"u":"https://note.youdao.com/yws/res/21541/WEBRESOURCEf58e77eb3e893f8c72a75e70af1752eb","w":573,"h":244},"6":"im"},{"3":"N0ME-1658480183981","4":{"version":1},"5":[{"2":"2","3":"QwHW-1658480183980","7":[{"8":"B树作为多路平衡查找树，它的每一个节点最多可以包括M个子节点，M称为B树的阶。每个磁盘块中包括了关键字和子节点的指针。如果一个磁盘块中包括了x个关键字，那么指针数就是x+1。对于一个10o阶的B树来说，如果有3层的话最多可以存储约100万的索引数据。对于大量的索引数据来说，采用B树的结构是非常适合的，因为树的高度要远小于二叉树的高度。"}]}]},{"3":"Cq4d-1658480184095","4":{"version":1},"5":[{"2":"2","3":"Zn6i-1658480184093","7":[{"8":"一个 M 阶的 B 树（M\u003e2）有以下的特性：","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"LDWJ-1658480813862","4":{"version":1},"5":[{"2":"2","3":"k8Hb-1658480813861","7":[{"8":"1. 根节点的儿子数的范围是 [2,M]。 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"dVJh-1658480813865","4":{"version":1},"5":[{"2":"2","3":"I5Kg-1658480813864","7":[{"8":"2. 每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 \u003d 关键字的数量 +1，k 的取值范围为[ceil(M/2), M]。 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"RoCO-1658480813869","4":{"version":1},"5":[{"2":"2","3":"W38E-1658480813868","7":[{"8":"3. 叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]。 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"uB76-1658480813871","4":{"version":1},"5":[{"2":"2","3":"KKFy-1658480813870","7":[{"8":"4. 假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i] \u003cKey[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …,P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k]指向关键字大于 Key[k-1] 的子树。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"lZaq-1658480813878","4":{"version":1},"5":[{"2":"2","3":"WqTx-1658480813877","7":[{"8":"5. 所有叶子节点位于同一层。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"ooFo-1658480184216","4":{"version":1},"5":[{"2":"2","3":"yk7A-1658480184214","7":[{"8":"上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15)大于 12，刚好符合刚才我们给出的特征。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"Xg9v-1658480831429","4":{"version":1},"5":[{"2":"2","3":"UmoT-1658480831428","7":[{"8":"然后我们来看下如何用 B 树进行查找。假设我们想要 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"查找的关键字是 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"9 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"，那么步骤可以分为以下几步：","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"pQlj-1658480184403","4":{"version":1},"5":[{"2":"2","3":"Gx0U-1658480184401","7":[{"8":"1. 我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1； ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"TM8B-1658480838724","4":{"version":1},"5":[{"2":"2","3":"z2gj-1658480838723","7":[{"8":"2. 按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2； ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"ATSo-1658480838726","4":{"version":1},"5":[{"2":"2","3":"jGP8-1658480838725","7":[{"8":"3. 按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"CULh-1658480184512","4":{"version":1},"5":[{"2":"2","3":"4PP7-1658480184511","7":[{"8":"你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素。 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"B ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"树相比于平衡二叉树来说磁盘 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"I/O ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"操作要少 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"，在数据查询中比平衡二叉树效率要高。所以 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"只要树的高度足够低，","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"IO","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"次数足够少，就可以提高查询性能 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]}]}]},{"3":"HxxN-1658480184606","4":{"l":"h3"},"5":[{"2":"2","3":"kFTv-1658480184605","7":[{"8":"B+Tree ","9":[{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"G6uh-1658480952941","4":{"version":1},"5":[{"2":"2","3":"JHAJ-1658480952938","7":[{"8":"B+树也是一种多路搜索树，基于B树做出了改进，主流的DBMS都支持B+树的索引方式，比如MysSQL。相比于B-Tree，B+Tree适合文件索引系统。"}]}]},{"3":"3d1p-1658480953447","4":{"version":1},"5":[{"2":"2","3":"jaqn-1658480953444","7":[{"8":"MySQL官网说明：","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"7rsA-1658481020788","4":{"version":1,"u":"https://note.youdao.com/yws/res/21552/WEBRESOURCE76d212de99289f0fdd7eb59d975b5d19","w":573,"h":222},"6":"im"},{"3":"sAXN-1658480953652","4":{"l":"h4"},"5":[{"2":"2","3":"wXeH-1658480953650","7":[{"8":"B+ ","9":[{"0":"#880000","2":"c"}]},{"8":"树和 ","9":[{"2":"b"},{"0":"#880000","2":"c"}]},{"8":"B ","9":[{"0":"#880000","2":"c"}]},{"8":"树的差异","9":[{"2":"b"},{"0":"#880000","2":"c"}]}]}],"6":"h"},{"3":"ypFV-1658480953744","4":{"version":1},"5":[{"2":"2","3":"ebb3-1658480953741","7":[{"8":"1. 有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 \u003d 关键字数，而 B 树中，孩子数量 \u003d 关键字数+1。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"L003-1658480953826","4":{"version":1},"5":[{"2":"2","3":"7M3t-1658480953824","7":[{"8":"2. 非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"zUH4-1658481040883","4":{"version":1},"5":[{"2":"2","3":"JY9K-1658481040882","7":[{"8":"3. 非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"非 叶子节点既保存索引，也保存数据记录 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"。 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"TCPz-1658481040888","4":{"version":1},"5":[{"2":"2","3":"zaAS-1658481040887","7":[{"8":"4. 所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"ZZkG-1658481248926","4":{"version":1},"5":[{"2":"2","3":"t5le-1658481248925","7":[{"8":"首先，B+树查询效率更稳定。因为B+树每次只有访问到叶子节点才能找到对应的数据，而在B树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。"}]}]},{"3":"h6lO-1658481249384","4":{"version":1},"5":[{"2":"2","3":"zu0m-1658481249383","7":[{"8":"其次，B+树的查询效率更高。这是因为通常B+树比B树更矮胖(阶数更大，深度更低)，查询所需要的磁盘I/O也会更少。同样的磁盘页大小，B+树可以存储更多的节点关键字。"}]}]},{"3":"3iSq-1658481249386","4":{"version":1},"5":[{"2":"2","3":"QpQj-1658481249385","7":[{"8":"不仅是对单个关键字的查询上，在查询范围上，B+树的效率也比B树高。这是因为所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在B树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。"}]}]},{"3":"OeP4-1658481040893","4":{"version":1},"5":[{"2":"2","3":"rJ5V-1658481040891","7":[{"8":"B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。","9":[{"0":"#777777","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"XqkQ-1658481049945","4":{"version":1},"5":[{"2":"2","3":"dQ6j-1658481049944","7":[{"8":"但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然","9":[{"0":"#777777","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"THHx-1658480953942","4":{"l":"h4"},"5":[{"2":"2","3":"1S21-1658480953939","7":[{"8":"思考题：","9":[{"2":"b"},{"0":"#880000","2":"c"}]}]}],"6":"h"},{"3":"uOUN-1658482526257","4":{"version":1},"5":[{"2":"2","3":"Icly-1658482526255","7":[{"8":"为了减少","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"IO","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"，索引树会一次性加载吗","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"2Z05-1658480954030","4":{"version":1},"5":[{"2":"2","3":"ROrs-1658480954028","7":[{"8":"1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G2、当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是逐—加载每一个磁盘页，因为磁盘页对应着索引树的节点。"}]}]},{"3":"JAz3-1658480954237","4":{"version":1},"5":[{"2":"2","3":"8Yun-1658480954235","7":[{"8":"思考题：","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"B+","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"树的存储能力如何？为何说一般查找行记录，最多只需","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"1~3","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"次磁盘","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"IO","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"Vc0A-1658482284575","4":{"version":1},"5":[{"2":"2","3":"0goT-1658482284573","7":[{"8":"InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT(占用4个字节）或BIGINT(占用8个字节)，指针类型也一般为4或8个字节，也就是说一个页(B+Tree中的一个节点)中大概存储16KB/(8B+8B)\u003d1K个键值（因为是伯值，3月1r记是。(这里假定一个数据页也存储10\u00273条行记录数据了)B+Tree索引可以维护10^3"},{"8":"10^3","9":[{"2":"b"}]},{"8":"10^3\u003d10亿条记录。(这里假定一个数据页也存储10^3条行记录数据了)"}]}]},{"3":"mjRf-1658482312148","4":{"version":1},"5":[{"2":"2","3":"MC1M-1658482312147","7":[{"8":"实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在2~4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘1/o操作。"}]}]},{"3":"tXW8-1658482282906","4":{"version":1},"5":[{"2":"2","3":"8pmn-1658482282905","7":[{"8":"思考题：为什么说","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"B+","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"树比","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"B-","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"树更适合实际应用中操作系统的文件索引和数据库索引？","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"G03M-1658482286105","4":{"version":1},"5":[{"2":"2","3":"fG8i-1658482286102","7":[{"8":"1、B+树的磁盘读写代价更低B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说Io读写次数也就降低了。"}]}]},{"3":"wJaS-1658482369808","4":{"version":1},"5":[{"2":"2","3":"Ghsr-1658482369807","7":[{"8":"2、B+树的查询效率更加稳定，由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。"}]}]},{"3":"ebUp-1658482282908","4":{"version":1},"5":[{"2":"2","3":"WsbB-1658482282907","7":[{"8":"思考题：","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"Hash ","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"索引与 ","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"B+ ","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"树索引的区别","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"ZUcO-1658482379097","4":{"version":1},"5":[{"2":"2","3":"P1Lr-1658482379096","7":[{"8":"1、Hash索引不能进行范围查询，而B+树可以。这是因为Hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表。"}]}]},{"3":"zjiL-1658482397934","4":{"version":1},"5":[{"2":"2","3":"ddbV-1658482397933","7":[{"8":"2、Hash索引不支持联合索引的最左侧原则(即联合索引的部分索引无法使用)，而B+树可以。对于联合索引来说，Hash索引在计算Hash值的时候是将索引键合并后再一起计算Hash值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。"}]}]},{"3":"ZK5w-1658482428863","4":{"version":1},"5":[{"2":"2","3":"EsEc-1658482428861","7":[{"8":"3、Hash索引不支持ORDER BY排序，因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而B+树索引数据是有序的，可以起到对该字段ORDER BY排序优化的作用。同理，我们也无法用Hash索引进行模糊查询，而B+树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询（比如%结尾的话就可以起到优化作用。"}]}]},{"3":"QrNT-1658482443988","4":{"version":1},"5":[{"2":"2","3":"GoPx-1658482443987","7":[{"8":"4、InnoDB 不支持哈希索引"}]}]},{"3":"cULe-1658482282910","4":{"version":1},"5":[{"2":"2","3":"8MiU-1658482282909","7":[{"8":"思考题：","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"Hash ","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"索引与 ","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"B+ ","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"树索引是在建索引的时候手动指定的吗？","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"p3we-1658480954345","4":{"version":1},"5":[{"2":"2","3":"rQwm-1658480954343","7":[{"8":"你能看到，针对InnoDB和MyISAM存储引擎，都会默认采用B+树索引，无法使用Hash索引。InnoDB提供的自适应Hash是不需要手动指定的。如果是Memory/Heap和NDB存储引擎，是可以进行选择Hash索引的。"}]}]},{"3":"Y9PM-1658482507809","4":{"l":"h3"},"5":[{"2":"2","3":"eGNB-1658482507807","7":[{"8":"R树"}]}],"6":"h"},{"3":"Km9y-1658482535054","4":{"version":1},"5":[{"2":"2","3":"D3AB-1658482535051","7":[{"8":"R-Tree在MySQL很少使用，仅支持 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"geometry","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"数据类型 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"，支持该类型的存储引擎只有myisam、bdb、 innodb、ndb、archive几种。举个R树在现实领域中能够解决的例子：查找20英里以内所有的餐厅。如果没有R树你会怎么解决？一般情况下我们会把餐厅的坐标(x,y)分为两个字段存放在数据库中，一个字段记录经度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满足要求。如果一个地区有100家餐厅的话，我们就要进行100次位置计算操作了，如果应用到谷歌、百度地图这种超大数据库中，这种方法便必定不可行了。R树就很好的 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"解决了这种高维空间搜索问题 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"。它把B树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解结点的方法，保证树的平衡性。因此，R树就是一棵用来 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"存储高维数据的平衡树 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"。相对于B-Tree，R-Tre的优势在于范围查找。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"H5pB-1658482604961","4":{"version":1,"u":"https://note.youdao.com/yws/res/21576/WEBRESOURCE8fd56dfd9d5915a281ece1507d3844c9","w":573,"h":69},"6":"im"},{"3":"uQwn-1658482535400","4":{"version":1},"5":[{"2":"2","3":"815h-1658482535398"}]},{"3":"xQ18-1658482508171","4":{"version":1},"5":[{"2":"2","3":"V8cR-1658482508170"}]}],"__compress__":true,"title":""}