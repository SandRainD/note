{"2":"1","3":"Ju9C-1621846617594","4":{"version":1,"incompatibleVersion":0,"headerStyle":{"t":"center"},"footerStyle":{"t":"center"},"fv":"0","hd":[{"8":"","p":1}],"ft":[{"8":"","p":1}]},"5":[{"3":"3060-1621846615933","5":[{"2":"2","3":"p5PQ-1621846617594","7":[{"8":"都有哪些维度可以进行数据库调优?简言之:"}]}]},{"3":"Tqxx-1658830080881","4":{"li":"276N-1658830091963","lt":"unordered","ll":1},"5":[{"2":"2","3":"odqo-1658830080880","7":[{"8":"索引失效、没有充分利用到索肴-―索引建立"}]}],"6":"l"},{"3":"nNCb-1658830076733","4":{"li":"276N-1658830091963","lt":"unordered","ll":1},"5":[{"2":"2","3":"dooj-1658830076731","7":[{"8":"关联查询太多JOIN(设计缺陷或不得已的需求)——SQL优化"}]}],"6":"l"},{"3":"malV-1658830086466","4":{"li":"276N-1658830091963","lt":"unordered","ll":1},"5":[{"2":"2","3":"Ig5k-1658830086465","7":[{"8":"服务器调优及各个参数设置(缓冲、线程数等）――调整my.cnf"}]}],"6":"l"},{"3":"G63e-1658830090214","4":{"li":"276N-1658830091963","lt":"unordered","ll":1},"5":[{"2":"2","3":"7o2i-1658830090213","7":[{"8":"数据过多――分库分表"}]}],"6":"l"},{"3":"Dsc5-1658830107426","5":[{"2":"2","3":"DOUT-1658830107424","7":[{"8":"虽然SQL查询优化的技术有很多，但是大方向上完全可以分成"},{"8":"物理查询优化和逻辑查询优化","9":[{"0":"#FB8D00","2":"c"}]},{"8":"两大块。"}]}]},{"3":"pi4M-1658830200993","4":{"li":"J1CJ-1658830205193","lt":"unordered","ll":1},"5":[{"2":"2","3":"0gGz-1658830200992","7":[{"8":"物理查询优化是通过索引和表连接方式等技术来进行优化，这里重点需要掌握索引的使用。"}]}],"6":"l"},{"3":"6zSq-1658830203265","4":{"li":"J1CJ-1658830205193","lt":"unordered","ll":1},"5":[{"2":"2","3":"4vF0-1658830203264","7":[{"8":"逻辑查询优化就是通过SQL等价变换提升查询效率，直白一点就是说，换一种查询写法执行效率可能更高。"}]}],"6":"l"},{"3":"T1xt-1658830108464","4":{"l":"h3"},"5":[{"2":"2","3":"8vh7-1658830108462","7":[{"8":"数据准备及课件","9":[{"0":"#000000","2":"c"}]}]}],"6":"h"},{"3":"Z9Yz-1658830538803","4":{"version":1,"sr":"https://note.youdao.com/yws/res/22419/WEBRESOURCETHUMB8b16dba769174c1ba73061cb5e6af168","re":"https://note.youdao.com/yws/res/22418/WEBRESOURCEfe9807aeb15cc00e35a2a137696785c7","fn":"第10章_索引优化与查询优化.pdf","fl":3560985},"6":"a"},{"3":"njcX-1658830552140","4":{"l":"h1"},"5":[{"2":"2","3":"c85P-1658830552141","7":[{"8":"索引失效案例","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"DV56-1658886740557","5":[{"2":"2","3":"otE0-1658886740558","7":[{"8":"MySQL中提高性能的一个最有效的方式是对数据表设计合理的索引。索引提供了高效访问数据的方法并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。"}]}]},{"3":"iE7W-1658886832068","4":{"li":"pph1-1658886839838","lt":"unordered","ll":1},"5":[{"2":"2","3":"Zuh4-1658886832067","7":[{"8":"使用索引可以快速地定位表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。"}]}],"6":"l"},{"3":"iqCv-1658886832070","4":{"li":"pph1-1658886839838","lt":"unordered","ll":1},"5":[{"2":"2","3":"HwOB-1658886832069","7":[{"8":"如果查询时没有使用索引，查询语句就会扫描表中的所有记录。在数据量大的情况下，这样查询的速度会很慢。"}]}],"6":"l"},{"3":"VgYM-1658886832072","4":{"version":1},"5":[{"2":"2","3":"RB8K-1658886832071","7":[{"8":"大多数情况下都（默认）采用B+树来构建索引。I只是空间列类型的索引使用R-树，并且MEMORY表还支持hash索引。"}]}]},{"3":"Ud6e-1658886865133","4":{"version":1},"5":[{"2":"2","3":"TAR2-1658886865131","7":[{"8":"其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器?基于cost开销(CostBaseOptimizer)，它不是基于规则(Rule-BasedOptimizer)，也不是基于语义。怎么样开销小就怎么来。另外，SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。"}]}]},{"3":"3F0E-1658830119449","4":{"l":"h3"},"5":[{"2":"2","3":"MPUY-1658830119448","7":[{"8":"全值匹配我最爱 ","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"ALbf-1658888045065","4":{"version":1,"u":"https://note.youdao.com/yws/res/22441/WEBRESOURCEb17329c3f91de2315b6557c51d1d5029","w":572,"h":135},"6":"im"},{"3":"P7v9-1658830119544","4":{"l":"h3"},"5":[{"2":"2","3":"WtqM-1658830119543","7":[{"8":"最佳左前缀法则","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"fvYH-1658830119657","5":[{"2":"2","3":"Pclm-1658830119656","7":[{"8":"在MysQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。"}]}]},{"3":"XJit-1658888397043","4":{"wrap":false,"la":"","th":"default"},"5":[{"3":"5GUt-1658888397042","5":[{"2":"2","3":"8IEv-1658830119750","7":[{"8":"CREATE INDEX idx_age_classid_name ON student(age,classId,NAME);"}]}],"6":"cl"},{"3":"PquC-1658888434978","5":[{"2":"2","3":"2JRD-1658888434976","7":[{"8":"EXPLAIN * FROM student"}]}],"6":"cl"},{"3":"dYRK-1658888488256","5":[{"2":"2","3":"uRiM-1658888488255","7":[{"8":"WHERE student.age=30 AND student.name = 'abcd ' ;"}]}],"6":"cl"},{"3":"0VUK-1658888510982","5":[{"2":"2","3":"FKdw-1658888510980","7":[{"8":"#这个时候查询语句可以使用idx_age_classid_name索引，但是由于无法匹配classid"}]}],"6":"cl"},{"3":"yTxy-1658888563536","5":[{"2":"2","3":"6gVi-1658888563534","7":[{"8":"#所以只能使用索引的一部分，key_len 为5"}]}],"6":"cl"}],"6":"cd"},{"3":"0N9g-1658830119847","5":[{"2":"2","3":"ajgk-1658830119845","7":[{"8":"结论:MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于多列索引，过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。如果查询条件中没有使用这些字段中第1个字段时，多列(或联合）索引不会被使用。"}]}]},{"3":"iBO6-1658830119957","4":{"l":"h3"},"5":[{"2":"2","3":"Wm88-1658830119956","7":[{"8":"主键插入顺序","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"k5YA-1658830120051","5":[{"2":"2","3":"P540-1658830120050","7":[{"8":"对于一个使用InnoDB存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在聚簇索引的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽大忽小的话，就比较麻烦了，假设某个数据页存储的记录已经满了，它存储的主键值在1~100之间:"}]}]},{"3":"xFg6-1658888791694","4":{"version":1,"u":"https://note.youdao.com/yws/res/22457/WEBRESOURCEd74b0c81dc6349e5caf25177b07ebe36","w":572,"h":225},"6":"im"},{"3":"9Dit-1658830120258","5":[{"2":"2","3":"mW8a-1658830120256","7":[{"8":"可这个数据页已经满了，再插进来咋办呢?我们需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么?意味着:性能损耗!所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值依次递增，这样就不会发生这样的性能损耗了。所以我们建议:让主键具有AUTO_INCRENENT，让存储引擎自己为表生成主键，而不是我们手动插入"}]}]},{"3":"UCkt-1658830120354","4":{"l":"h3"},"5":[{"2":"2","3":"Mfbe-1658830120353","7":[{"8":"计算、函数、类型转换","9":[{"2":"b"},{"0":"#34495e","2":"c"}]},{"8":"(","9":[{"0":"#34495e","2":"c"}]},{"8":"自动或手动","9":[{"2":"b"},{"0":"#34495e","2":"c"}]},{"8":")","9":[{"0":"#34495e","2":"c"}]},{"8":"导致索引失效","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"GBOn-1658889350643","4":{"wrap":false,"la":"","th":"default"},"5":[{"3":"0PU7-1658889350642","5":[{"2":"2","3":"upE8-1658830120466","7":[{"8":"CREATE INDEX idx_name ON student(NAME); "}]}],"6":"cl"},{"3":"9tic-1658889358400","5":[{"2":"2","3":"spnk-1658889358398","7":[{"8":"EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE 'abc%'; "}]}],"6":"cl"},{"3":"v0CX-1658889353441","5":[{"2":"2","3":"G0tq-1658889353440","7":[{"8":"EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = 'abc';"}]}],"6":"cl"},{"3":"RFwg-1658889369016","5":[{"2":"2","3":"qSOX-1658889369014","7":[{"8":"#第一种索引优化生效，第二种索引优化失效 "}]}],"6":"cl"},{"3":"A2zD-1658889478163","5":[{"2":"2","3":"4HzW-1658889478161","7":[{"8":"EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno = 900000;"}]}],"6":"cl"},{"3":"IUL3-1658889501166","5":[{"2":"2","3":"juql-1658889501165","7":[{"8":"EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno+1 = 900001;"}]}],"6":"cl"}],"6":"cd"},{"3":"2ezu-1658830120561","4":{"l":"h3"},"5":[{"2":"2","3":"8Mf7-1658830120559","7":[{"8":"类型转换导致索引失效","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"m8JS-1658889564142","4":{"wrap":false,"la":"","th":"default"},"5":[{"3":"5cWH-1658889564140","5":[{"2":"2","3":"zcWS-1658830120657","7":[{"8":"# 未使用到索引 ，name使用函数转换后与123比较"}]}],"6":"cl"},{"3":"dJFh-1658889564323","5":[{"2":"2","3":"w9uz-1658889564322","7":[{"8":"EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=123; "}]}],"6":"cl"},{"3":"RxEP-1658889566086","5":[{"2":"2","3":"Pgoz-1658889566085","7":[{"8":"# 使用到索引 "}]}],"6":"cl"},{"3":"BJgL-1658889570618","5":[{"2":"2","3":"7Cqi-1658889570617","7":[{"8":"EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name='123'; "}]}],"6":"cl"}],"6":"cd"},{"3":"F6OC-1658889623445","4":{"l":"h3"},"5":[{"2":"2","3":"RNB1-1658889623444","7":[{"8":"范围条件右边的列索引失效","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"zoOS-1658889799741","4":{"wrap":false,"la":"","th":"default"},"5":[{"3":"rh5v-1658889799740","5":[{"2":"2","3":"EyY9-1658830120863","7":[{"8":"create index idx_age_name_classid on student(age,classid,name); "}]}],"6":"cl"},{"3":"IaXT-1658889800947","5":[{"2":"2","3":"d6hQ-1658889800945","7":[{"8":"EXPLAIN SELECT SQL_NO_CACHE * FROM student "}]}],"6":"cl"},{"3":"rjTK-1658889805360","5":[{"2":"2","3":"Krx0-1658889805359","7":[{"8":"WHERE student.age=30 AND student.classId>20 AND student.name = 'abc' ;"}]}],"6":"cl"},{"3":"rJAE-1658889814850","5":[{"2":"2","3":"vHuo-1658889814848","7":[{"8":"# 由于classID进行了范围匹配后面的name字段就无法使用索引了"}]}],"6":"cl"}],"6":"cd"},{"3":"GBmp-1658830120961","4":{"l":"h3"},"5":[{"2":"2","3":"kvOj-1658830120960","7":[{"8":"不等于","9":[{"2":"b"},{"0":"#34495e","2":"c"}]},{"8":"(!= ","9":[{"0":"#34495e","2":"c"}]},{"8":"或者","9":[{"2":"b"},{"0":"#34495e","2":"c"}]},{"8":"<>)","9":[{"0":"#34495e","2":"c"}]},{"8":"索引失效 (非主键","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"qRT3-1658890098096","4":{"wrap":false,"la":"","th":"default"},"5":[{"3":"Pfad-1658890098095","5":[{"2":"2","3":"ci9a-1658830121071","7":[{"8":"CREATE INDEX idx_name ON student(NAME);"}]}],"6":"cl"},{"3":"O4JF-1658890109614","5":[{"2":"2","3":"rKSa-1658890109613","7":[{"8":"EXPLAIN SELECT * FROM student WHERE student.name <> 'abc';#索引失效"}]}],"6":"cl"}],"6":"cd"},{"3":"MuLb-1658890212209","4":{"l":"h3"},"5":[{"2":"2","3":"4NDY-1658890212208","7":[{"8":"is null","9":[{"0":"#34495e","2":"c"}]},{"8":"可以使用索引，","9":[{"2":"b"},{"0":"#34495e","2":"c"}]},{"8":"is not null","9":[{"0":"#34495e","2":"c"}]},{"8":"无法使用索引 ","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"CL3V-1658890241915","4":{"wrap":false,"la":"","th":"default"},"5":[{"3":"GFR1-1658890241914","5":[{"2":"2","3":"hF7d-1658830121263","7":[{"8":"EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age IS NULL; "}]}],"6":"cl"},{"3":"fgGh-1658890242567","5":[{"2":"2","3":"aBWI-1658890242566","7":[{"8":"EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age IS NOT NULL; "}]}],"6":"cl"}],"6":"cd"},{"3":"icRx-1658830121375","5":[{"2":"2","3":"Isyg-1658830121374","7":[{"8":"结论:最好在设计数据表的时候就将字段设置为NOT NULL约束，比如你可以将INT类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串()。"}]}]},{"3":"SdSp-1658890289723","4":{"version":1},"5":[{"2":"2","3":"C2Ku-1658890289722","7":[{"8":"拓展:同理，在查询中使用not like 也无法使用索引，导致全表扫描。"}]}]},{"3":"fIF3-1658830121470","4":{"l":"h3"},"5":[{"2":"2","3":"nGib-1658830121469","7":[{"8":"like","9":[{"0":"#34495e","2":"c"}]},{"8":"以通配符","9":[{"2":"b"},{"0":"#34495e","2":"c"}]},{"8":"%","9":[{"0":"#34495e","2":"c"}]},{"8":"开头索引失效","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"4QAm-1658830121564","5":[{"2":"2","3":"wPOi-1658830121563","7":[{"8":"拓展：","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"Alibaba","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"《","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"Java","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"开发手册》","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"2mgf-1658890369012","4":{"version":1},"5":[{"2":"2","3":"tFel-1658890369011","7":[{"8":"【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。","9":[{"0":"#777777","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"7GB0-1658890378974","4":{"l":"h3"},"5":[{"2":"2","3":"t976-1658890378973","7":[{"8":"OR ","9":[{"0":"#34495e","2":"c"}]},{"8":"前后存在非索引的列，索引失效","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"pIET-1658890486398","4":{"wrap":false,"la":"","th":"default"},"5":[{"3":"ytTT-1658890486397","5":[{"2":"2","3":"lZ7P-1658890220583","7":[{"8":"CREATEINDEX idx_age ON student (age) ;"}]}],"6":"cl"},{"3":"KMZL-1658890495406","5":[{"2":"2","3":"YZ7n-1658890495405","7":[{"8":"EXPLAIN SELECT * FROM student WHERE age = 10 OR classid = 100;"}]}],"6":"cl"},{"3":"tuww-1658890495408","5":[{"2":"2","3":"ngIU-1658890495407","7":[{"8":"#结果仍然是全表扫描"}]}],"6":"cl"}],"6":"cd"},{"3":"5YO9-1658890557255","4":{"l":"h3"},"5":[{"2":"2","3":"yu9q-1658890557254","7":[{"8":"数据库和表的字符集统一使用","9":[{"2":"b"},{"0":"#34495e","2":"c"}]},{"8":"utf8mb4","9":[{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"dPLw-1658890220792","5":[{"2":"2","3":"rVVf-1658890220791","7":[{"8":"统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"字符集 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"进行比较前需要进行 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"转换 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"会造成索引失效。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"ZoHb-1658890220888","4":{"l":"h3"},"5":[{"2":"2","3":"bkGL-1658890220887","7":[{"8":"小结","9":[{"0":"#000000","2":"c"}]}]}],"6":"h"},{"3":"cp3S-1658890220984","4":{"li":"jPJ0-1658890699850","lt":"unordered","ll":1},"5":[{"2":"2","3":"23L5-1658890220983","7":[{"8":"对于单列索引，尽量选择针对当前query过滤性更好的索引"}]}],"6":"l"},{"3":"u8mB-1658890690977","4":{"li":"jPJ0-1658890699850","lt":"unordered","ll":1},"5":[{"2":"2","3":"JaNk-1658890690976","7":[{"8":"在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。"}]}],"6":"l"},{"3":"CVr3-1658890694249","4":{"li":"jPJ0-1658890699850","lt":"unordered","ll":1},"5":[{"2":"2","3":"49ok-1658890694248","7":[{"8":"在选择组合索引的时候，尽量选择能够包含当前query中的where子句中更多字段的索引。"}]}],"6":"l"},{"3":"cdAv-1658890690979","4":{"li":"jPJ0-1658890699850","lt":"unordered","ll":1},"5":[{"2":"2","3":"Jy8e-1658890690978","7":[{"8":"在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。"}]}],"6":"l"},{"3":"TxOK-1658890221096","4":{"l":"h1"},"5":[{"2":"2","3":"bBGC-1658890221095","7":[{"8":"关联查询优化","9":[{"0":"#000000","2":"c"}]}]}],"6":"h"},{"3":"wxfU-1658891297523","4":{"l":"h3"},"5":[{"2":"2","3":"hwSN-1658891297522","7":[{"8":"采用左外连接","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"mkV7-1658891310700","4":{"wrap":false,"la":"","th":"default"},"5":[{"3":"XPo2-1658891310699","5":[{"2":"2","3":"ni3Z-1658890596264","7":[{"8":"EXPLAIN SELECT * FROM `type` LEFT JOIN book ON type.card = book.card;"}]}],"6":"cl"},{"3":"Xrhy-1658891326144","5":[{"2":"2","3":"1AZ9-1658891326143","7":[{"8":"# 添加索引优化"}]}],"6":"cl"},{"3":"H79O-1658891334189","5":[{"2":"2","3":"LamB-1658891334188","7":[{"8":"ALTER TABLE book ADD INDEX Y ( card); #【被驱动表】，可以避免全表扫描 "}]}],"6":"cl"},{"3":"pirr-1658891342805","5":[{"2":"2","3":"rYSM-1658891342804","7":[{"8":"#再运行SQL分析工具，发现被驱动表使用索引；"}]}],"6":"cl"},{"3":"a7AH-1658891405939","5":[{"2":"2","3":"in7G-1658891405937","7":[{"8":"#驱动表是ALL全表扫描，但是因为是左外连接，可以接受，右表(被驱动)一定要有索引"}]}],"6":"cl"}],"6":"cd"},{"3":"ImFH-1658890596774","5":[{"2":"2","3":"BLv9-1658890596772","7":[{"8":"注意：多表连接条件WHERE中，两者的类型必须相同，否则隐式转换索引会失效","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"RijG-1658890596882","4":{"l":"h3"},"5":[{"2":"2","3":"Rirm-1658890596881","7":[{"8":"采用内连接","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"Dnmj-1658890596979","5":[{"2":"2","3":"nkXm-1658890596978","7":[{"8":"两个表都有索引的情况，","9":[{"0":"#000000","2":"c"}]},{"8":"对于内连接来说，查询优化器可以决定谁作为驱动表，谁作为被驱动表出现的"}]}]},{"3":"oMRW-1658891992035","4":{"wrap":false,"la":"","th":"default"},"5":[{"3":"iDUs-1658891992034","5":[{"2":"2","3":"wJ2b-1658890597074","7":[{"8":"EXPLAIN SELECT * FROM `type` INNER JOIN book ON type.card=book.card;"}]}],"6":"cl"}],"6":"cd"},{"3":"7dUk-1658890597172","5":[{"2":"2","3":"JA8Q-1658890597171","7":[{"8":"对于内连接来讲，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表","9":[{"0":"#000000","2":"c"}]},{"8":"出现"}]}]},{"3":"ef8R-1658890597282","5":[{"2":"2","3":"Es0E-1658890597281","7":[{"8":"对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。\"小表驱动大表\""}]}]},{"3":"hZKV-1658890597377","4":{"l":"h3"},"5":[{"2":"2","3":"Lj01-1658890597376","7":[{"8":"JOIN语句原理"}]}],"6":"h"},{"3":"dD3n-1658898359421","4":{"version":1},"5":[{"2":"2","3":"y6UJ-1658898359422","7":[{"8":"join方式连接多个表，本质就是各个表之间数据的循环匹配。MySQL5.5版本之前，MysQL只支持一种表间关联方式，就是嵌套循环(Nested Loop Join)。如果关联表的数据量很大，则join关联的执行时间会非常长在MySQL5.5以后的版本中，MySQL通过引入BNLJ算法来优化嵌套执行。"}]}]},{"3":"7OjH-1658890597490","4":{"l":"h4"},"5":[{"2":"2","3":"RHVt-1658890597489","7":[{"8":"驱动表和被驱动表"}]}],"6":"h"},{"3":"Mh0B-1658890597585","5":[{"2":"2","3":"CRqE-1658890597584","7":[{"8":"驱动表就是主表，被驱动表就是从表、非驱动表"}]}]},{"3":"fb2D-1658897717926","5":[{"2":"2","3":"Q8N8-1658897717925","7":[{"8":"除了内连接，优化器也会将外连接进行优化，这样的优化有可能使驱动表和被驱动表的位置互换"}]}]},{"3":"eXI6-1658897718426","4":{"l":"h4"},"5":[{"2":"2","3":"dz6k-1658897718424","7":[{"8":"Simple Nested-Loop Join（简单嵌套循环连接）"}]}],"6":"h"},{"3":"97JY-1658897718536","5":[{"2":"2","3":"iZ6Z-1658897718535","7":[{"8":"算法相当简单，从表A中取出一条数据1，遍历表B，将匹配到的数据放到result..l以此类推，驱动表A中的每一条记录与被驱动表B的记录进行判断:"}]}]},{"3":"dhob-1658898738626","4":{"version":1,"u":"https://note.youdao.com/yws/res/22551/WEBRESOURCE8d8a7ad71e46b1aee22ed004957d6b68","w":532,"h":205},"6":"im"},{"3":"RNcN-1658898576037","5":[{"2":"2","3":"Ce1l-1658898576036","7":[{"8":"可以看到这种效率是很低的"}]}]},{"3":"cc6Z-1658900131639","4":{"version":1,"u":"https://note.youdao.com/yws/res/22557/WEBRESOURCEbdde92b6d95e86ab4e817b07a062f918","w":572,"h":157},"6":"im"},{"3":"FqoO-1658898576467","4":{"l":"h4"},"5":[{"2":"2","3":"kSFV-1658898576465","7":[{"8":"Index Nested-Loop Join","9":[{"0":"#880000","2":"c"}]}]}],"6":"h"},{"3":"UhLh-1658898577202","5":[{"2":"2","3":"NyLV-1658898577201","7":[{"8":"Index Nested-Loop Join其优化的思路主要是为了"},{"8":"减少内层表数据的匹配次数","9":[{"0":"#FB8D00","2":"c"}]},{"8":"，所以要求被驱动表上必须有索引才行。通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录去进行比较，这样极大的减少了对内层表的匹配次数。"}]}]},{"3":"dR8D-1658900145805","4":{"version":1,"u":"https://note.youdao.com/yws/res/22559/WEBRESOURCE91d9094d02dd1349f58c4d86cb56c6a0","w":572,"h":243},"6":"im"},{"3":"brIm-1658900209720","4":{"version":1,"u":"https://note.youdao.com/yws/res/22561/WEBRESOURCE2b9fab69e5909f40803426657640f2f4","w":572,"h":159},"6":"im"},{"3":"VCdh-1658897718933","5":[{"2":"2","3":"oH9Y-1658897718932","7":[{"8":"Block Nested-Loop Join（块嵌套循环连接）"}]}]},{"3":"oGXI-1658897719029","5":[{"2":"2","3":"U937-1658897719028","7":[{"8":"如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录在加载到内存匹配，这样周而复始，大大增加了Io的次数。为了减少被驱动表的Io次数，就出现了Block Nested-Loop Join的方式。"}]}]},{"3":"JOHX-1658900370410","4":{"version":1},"5":[{"2":"2","3":"UkIU-1658900370409","7":[{"8":"不再是逐条获取驱动表的数据，而是一块一块的获取，引入了join buffer缓冲区，将驱动表join相关的部分数据列(大小受join buffer的限制缓存到join buffer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和joinbuffer中的所有驱动表记录进行匹配(内存中操作)，将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。"}]}]},{"3":"Y9rm-1658897719139","5":[{"2":"2","3":"6y4H-1658897719138","7":[{"8":"注意:"}]}]},{"3":"gkNB-1658900402203","4":{"version":1},"5":[{"2":"2","3":"sClu-1658900402202","7":[{"8":"这里缓存的不只是关联表的列,select后面的列也会缓存起来。在一个有N个join关联的sql中会分配N-1个join buffer。所以查询的时候尽量减少不必要的字段，可以让joinbuffer中可以存放更多的列。"}]}]},{"3":"vgHa-1658900476690","4":{"version":1,"u":"https://note.youdao.com/yws/res/22567/WEBRESOURCEc4a9bc5dbf03fcf0eff1ec770b5d91c7","w":572,"h":249},"6":"im"},{"3":"evhx-1658900484169","4":{"version":1,"u":"https://note.youdao.com/yws/res/22569/WEBRESOURCE9cb365d17505e8af9f09159c7b1970e0","w":572,"h":159},"6":"im"},{"3":"aw3v-1658897719448","5":[{"2":"2","3":"UNZZ-1658897719447","7":[{"8":"参数设置："}]}]},{"3":"OFFl-1658900568100","5":[{"2":"2","3":"yf3A-1658900568098","7":[{"8":"block_nested_loop"}]}]},{"3":"llHg-1658897719541","5":[{"2":"2","3":"mEdD-1658897719540","7":[{"8":"通过show variables like '%optimizer_switch%查看block_nested_loop状态。默认是开启的。"}]}]},{"3":"KhIv-1658897719636","5":[{"2":"2","3":"XJ5m-1658897719635","7":[{"8":"join_buffer_size"}]}]},{"3":"aAQV-1658897719745","5":[{"2":"2","3":"9EhB-1658897719744","7":[{"8":"驱动表能不能一次加载完，要看join buffer能不能存储所有的数据，默认情况下join_buffer_size=256k。join_buffer_size的最大值在32位系统可以申请4G，而在64位操做系统下可以申请大于4G的Join Buffer空间(64位Windows除外，其大值会被截断为4GB并发出警告)。"}]}]},{"3":"0aEG-1658897719842","4":{"l":"h4"},"5":[{"2":"2","3":"gcZh-1658897719840","7":[{"8":"小结"}]}],"6":"h"},{"3":"Wnqq-1658897739362","4":{"li":"s8A8-1658900944110","lt":"ordered","ll":1},"5":[{"2":"2","3":"Hs1D-1658897739361","7":[{"8":"整体效率比较:INLJ > BNLJ > SNLJ","9":[{"0":"#CC0000","2":"c"}]}]}],"6":"l"},{"3":"HEuZ-1658900718502","4":{"li":"s8A8-1658900944110","lt":"ordered","ll":1},"5":[{"2":"2","3":"nYVE-1658900718501","7":[{"8":"永远用小结果集驱动大结果集(其本质就是减少外层循环的数据数量) (小的度量单位指的是表行数*每行大小)"}]}],"6":"l"},{"3":"HSSr-1658897739864","4":{"li":"s8A8-1658900944110","lt":"ordered","ll":1},"5":[{"2":"2","3":"S34X-1658897739863","7":[{"8":"为被驱动表匹配的条件增加索引(减少内层表的循环匹配次数)"}]}],"6":"l"},{"3":"0UEI-1658900863963","4":{"li":"s8A8-1658900944110","lt":"ordered","ll":1},"5":[{"2":"2","3":"9rgp-1658900863962","7":[{"8":"增大join buffer size的大小(一次缓存的数据越多，那么内层包的扫表次数就越少)"}]}],"6":"l"},{"3":"Y1Sv-1658900868079","4":{"li":"s8A8-1658900944110","lt":"ordered","ll":1},"5":[{"2":"2","3":"KiHs-1658900868078","7":[{"8":"减少驱动表不必要的字段查询(字段越少，join buffer所缓存的数据就越多)"}]}],"6":"l"},{"3":"QBwW-1658897739975","4":{"l":"h4"},"5":[{"2":"2","3":"LBTD-1658897739974","7":[{"8":"Hash Join"}]}],"6":"h"},{"3":"FqVc-1658897740069","5":[{"2":"2","3":"Crm6-1658897740068","7":[{"8":"从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash join","9":[{"0":"#CC0000","2":"c"}]}]}]},{"3":"tuDd-1658897740164","4":{"li":"CIjy-1658901076995","lt":"unordered","ll":1},"5":[{"2":"2","3":"WEta-1658897740163","7":[{"8":"Nested Loop:对于被连接的数据子集较小的情况，Nested Loop是个较好的选择。"}]}],"6":"l"},{"3":"Gukz-1658901068178","4":{"li":"CIjy-1658901076995","lt":"unordered","ll":1},"5":[{"2":"2","3":"s1Mk-1658901068177","7":[{"8":"Hash Join是做大数据集连接时的常用方式，优化器使用两个表中较小(相对较小)的表利用Join Key在内存中建立散列表，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。"}]}],"6":"l"},{"3":"E2vX-1658901068180","4":{"li":"CIjy-1658901076995","lt":"unordered","ll":2},"5":[{"2":"2","3":"LTD9-1658901068179","7":[{"8":"这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。"}]}],"6":"l"},{"3":"oWLU-1658901068182","4":{"li":"CIjy-1658901076995","lt":"unordered","ll":2},"5":[{"2":"2","3":"sSu4-1658901068181","7":[{"8":"在表很大的情况下并不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/o的性能。 "}]}],"6":"l"},{"3":"trm3-1658901068184","4":{"li":"CIjy-1658901076995","lt":"unordered","ll":2},"5":[{"2":"2","3":"qb3J-1658901068183","7":[{"8":"它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是Join的重型升降机。Hash Join只能应用于等值连接(如WHERE A.COL1=B.COL2)，这是由Hash的特点决定的。"}]}],"6":"l"},{"3":"Wtao-1658897740275","4":{"l":"h1"},"5":[{"2":"2","3":"seO4-1658897740274","7":[{"8":"子查询优化","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"g0OL-1658897740372","5":[{"2":"2","3":"BaB6-1658897740371","7":[{"8":"MySQL从4.1版本开始支持子查询，使用子查询可以进行SELECT语句的嵌套查询，即一个SELECT查询的结","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"Ip25-1658901200958","4":{"version":1},"5":[{"2":"2","3":"SJuP-1658901200957","7":[{"8":"果作为另一个SELECT语句的条件。 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"子查询可以一次性完成很多逻辑上需要多个步骤才能完成的","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"SQL","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"操作 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"hes8-1658901200961","4":{"version":1},"5":[{"2":"2","3":"7Qxo-1658901200960","7":[{"8":"子查询是 ","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"MySQL ","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"的一项重要的功能，可以帮助我们通过一个 ","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"SQL ","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"语句实现比较复杂的查询。但是，子查询的执行效率不高。","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"原因：","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"Obbv-1658901200965","4":{"version":1},"5":[{"2":"2","3":"N2Nk-1658901200964","7":[{"8":"① 执行子查询时，MySQL需要为内层查询语句的查询结果 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"建立一个临时表 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"，然后外层查询语句从临时表中查询记录。查询完毕后，再 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"撤销这些临时表 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"。这样会消耗过多的CPU和IO资源，产生大量的慢查询。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"SDTX-1658901200970","4":{"version":1},"5":[{"2":"2","3":"XDHU-1658901200969","7":[{"8":"② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"不会存在索引 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"，所以查询性能会受到一定的影响。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"LUdJ-1658901200975","4":{"version":1},"5":[{"2":"2","3":"G9kg-1658901200974","7":[{"8":"③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"6CXu-1658901686751","4":{"version":1},"5":[{"2":"2","3":"Kvhu-1658901686740","7":[{"8":"在","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"MySQL","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"中，可以使用连接（","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"JOIN","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"）查询来替代子查询。","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"连接查询 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"不需要建立临时表","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"，其 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"速度比子查询要快 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"，如果查询中使用索引的话，性能就会更好","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"oUsl-1658901188627","5":[{"2":"2","3":"dbtI-1658901188626","7":[{"8":"结论：尽量不要使用NOT IN 或者 NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代","9":[{"0":"#777777","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"fjYm-1658901189143","4":{"l":"h1"},"5":[{"2":"2","3":"289Y-1658901189141","7":[{"8":"排序优化","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"HmqS-1658901189253","5":[{"2":"2","3":"8YMY-1658901189252","7":[{"8":"在MySQL中，支持两种排序方式，分别是FileSort和Index排序。"}]}]},{"3":"9L1T-1658902650240","4":{"li":"9wDg-1658906564845","lt":"unordered","ll":1},"5":[{"2":"2","3":"o5IE-1658902650239","7":[{"8":"lndex排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高。"}]}],"6":"l"},{"3":"kgYt-1658902650242","4":{"li":"9wDg-1658906564845","lt":"unordered","ll":1},"5":[{"2":"2","3":"x0WZ-1658902650241","7":[{"8":"FileSort排序则一般在内存中进行排序，占用CPU较多。如果待排结果较大，会产生临时文件I/o到磁盘进行排序的情况，效率较低。"}]}],"6":"l"},{"3":"RQEj-1658902634771","4":{"li":"HQHO-1658902583707","lt":"ordered","ll":1},"5":[{"2":"2","3":"0KLJ-1658902634768","7":[{"8":"SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"避免全表扫 描 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"，在 ORDER BY 子句 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"避免使用 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"FileSort ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"排序 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"D26e-1658902567590","4":{"li":"HQHO-1658902583707","lt":"ordered","ll":1},"5":[{"2":"2","3":"aBPw-1658902567589","7":[{"8":"尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"91cQ-1658902567594","4":{"li":"HQHO-1658902583707","lt":"ordered","ll":1},"5":[{"2":"2","3":"8EmG-1658902567593","7":[{"8":"无法使用 Index 时，需要对 FileSort 方式进行调优","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"11y2-1658918191116","4":{"version":1,"u":"https://note.youdao.com/yws/res/b/WEBRESOURCEf1a78fe45ed8af124f8cefdbdf16c7db","w":946,"h":369},"6":"im"},{"3":"FPJb-1658920735087","4":{"version":1,"u":"https://note.youdao.com/yws/res/9/WEBRESOURCEbae31ade3728a0b738137baf8526ec39","w":567,"h":179},"6":"im"},{"3":"lttl-1658921021099","4":{"version":1,"u":"https://note.youdao.com/yws/res/5/WEBRESOURCE5c9d6b244de3f48f38a63aa51b006795","w":567,"h":117},"6":"im"},{"3":"VUEN-1658921345105","4":{"version":1,"u":"https://note.youdao.com/yws/res/a/WEBRESOURCE6b15e71bbdd82288a4a4f8f3ea0feefa","w":567,"h":169},"6":"im"},{"3":"ajo7-1658921568106","4":{"version":1,"u":"https://note.youdao.com/yws/res/3/WEBRESOURCEc2a7e73afaab6d814f7ab8bd0446ec03","w":567,"h":168},"6":"im"},{"3":"xoil-1658897740887","4":{"l":"h3"},"5":[{"2":"2","3":"cd56-1658897740886","7":[{"8":"filesort算法:双路排序和单路排序"}]}],"6":"h"},{"3":"3OOa-1658897740979","5":[{"2":"2","3":"GJW6-1658897740978","7":[{"8":"排序的字段若如果不在索引列上，则filesort会有两种算法:双路排序和单路排序"}]}]},{"3":"eMba-1658897741075","5":[{"2":"2","3":"xsml-1658897741074","7":[{"8":"双路排序（慢)","9":[{"0":"#A00E0EFF","2":"c"},{"2":"b"},{"2":"d"}]}]}]},{"3":"D1we-1658922490537","4":{"li":"Ip6v-1658922502624","lt":"unordered","ll":1},"5":[{"2":"2","3":"EFE6-1658922490536","7":[{"8":"MySQL 4.1之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据，读取行指针和order by列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出"}]}],"6":"l"},{"3":"BUaZ-1658922490539","4":{"li":"Ip6v-1658922502624","lt":"unordered","ll":1},"5":[{"2":"2","3":"rM94-1658922490538","7":[{"8":"从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。|I"}]}],"6":"l"},{"3":"5q4w-1658922490541","4":{"version":1},"5":[{"2":"2","3":"4U7b-1658922490540","7":[{"8":"取一批数据，要对磁盘进行两次扫描，众所周知，l0是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。"}]}]},{"3":"9l3W-1658897741187","5":[{"2":"2","3":"FHSb-1658897741185","7":[{"8":"单路排序(快)","9":[{"0":"#A00E0EFF","2":"c"},{"2":"b"}]}]}]},{"3":"CWt8-1658922693753","4":{"version":1},"5":[{"2":"2","3":"RQ32-1658922693752","7":[{"8":"从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机lO变成了顺序Io，但是它会使用更多的空间，因为它把每一行都保存在内存中了。"}]}]},{"3":"pSG5-1658897741282","4":{"li":"b350-1658922924956","lt":"unordered","ll":1},"5":[{"2":"2","3":"iKID-1658897741281","7":[{"8":"在sort_buffer中，单路比多路要多占用很多空间，因为单路是把所有字段都取出,所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并)，排完再取sort_buffer容量大小，再排......从而多次I/O。"}]}],"6":"l"},{"3":"rOXs-1658922921216","4":{"li":"b350-1658922924956","lt":"unordered","ll":1},"5":[{"2":"2","3":"NZfG-1658922921215","7":[{"8":"单路本来想省一次I/o操作，反而导致了大量的I/0操作，反而得不偿失。"}]}],"6":"l"},{"3":"5GS0-1658897741379","5":[{"2":"2","3":"T5jO-1658897741378","7":[{"8":"优化策略","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"CovF-1658922641720","5":[{"2":"2","3":"cXzj-1658922641719","7":[{"8":"1. ","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"尝试提高 ","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"sort_buffer_size ","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"XH9J-1658922642218","5":[{"2":"2","3":"Xrcj-1658922642217","7":[{"8":"2. ","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"尝试提高 ","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"max_length_for_sort_data ","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"oTSl-1658923009728","5":[{"2":"2","3":"PWnQ-1658923009726","7":[{"8":"但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率。如果需要返回的列的总长度大于max_length_for_sortl_data，使用双路算法，否则使用单路算法。1024-8192字节之间调整"}]}]},{"3":"Fyok-1658922642328","5":[{"2":"2","3":"kCRt-1658922642326","7":[{"8":"3. Order by ","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"时","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"select * ","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"是一个大忌。最好只","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"Query","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"需要的字段。","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"npex-1658922642423","4":{"l":"h1"},"5":[{"2":"2","3":"tBWa-1658922642421","7":[{"8":"GROUP BY","9":[{"0":"#34495e","2":"c"}]},{"8":"优化","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"TmpM-1658922642534","4":{"li":"X4xZ-1658923094383","lt":"unordered","ll":1},"5":[{"2":"2","3":"qI9L-1658922642533","7":[{"8":"group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"kiyu-1658923076682","4":{"li":"X4xZ-1658923094383","lt":"unordered","ll":1},"5":[{"2":"2","3":"WukQ-1658923076681","7":[{"8":"group by 先排序再分组，遵照索引建的最佳左前缀法则","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"APka-1658923076684","4":{"li":"X4xZ-1658923094383","lt":"unordered","ll":1},"5":[{"2":"2","3":"wNTt-1658923076683","7":[{"8":"当无法使用索引列，增大 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"max_length_for_sort_data ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"和 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"sort_buffer_size ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"参数的设置","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"EOHb-1658923076686","4":{"li":"X4xZ-1658923094383","lt":"unordered","ll":1},"5":[{"2":"2","3":"j3yZ-1658923076685","7":[{"8":"where效率高于having，能写在where限定的条件就不要写在having中了","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"JCmb-1658923076688","4":{"li":"X4xZ-1658923094383","lt":"unordered","ll":1},"5":[{"2":"2","3":"hEOQ-1658923076687","7":[{"8":"减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"z5A6-1658923076692","4":{"li":"X4xZ-1658923094383","lt":"unordered","ll":1},"5":[{"2":"2","3":"zk3b-1658923076691","7":[{"8":"包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"haLg-1658923287425","4":{"l":"h1"},"5":[{"2":"2","3":"O9qU-1658923287424","7":[{"8":"优化分页查询","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"Dbe6-1658922642724","5":[{"2":"2","3":"hW2e-1658922642723","7":[{"8":"一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是limit 20o0000,10，此时需要MysQL排序前2000010记录，仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。"}]}]},{"3":"sbwW-1658923387361","4":{"wrap":false,"la":"","th":"default"},"5":[{"3":"j8HI-1658923387360","5":[{"2":"2","3":"VoVm-1658922642835","7":[{"8":"EXPLAIN SELECT* FROM student LIMIT 20000000,10;"}]}],"6":"cl"}],"6":"cd"},{"3":"vqGB-1658890597680","5":[{"2":"2","3":"7gml-1658890597679","7":[{"8":"查询从200万条记录开始的10条数据"}]}]},{"3":"T1Ah-1658923052628","5":[{"2":"2","3":"gpjW-1658923052626","7":[{"8":"优化思路一","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"qgaP-1658923053131","5":[{"2":"2","3":"2za8-1658923053130","7":[{"8":"在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"ZnLU-1658923533652","4":{"version":1,"u":"https://note.youdao.com/yws/res/5/WEBRESOURCE9a80f341c3d263b881905fe59bc85525","w":581,"h":50},"6":"im"},{"3":"9tYQ-1658923053243","5":[{"2":"2","3":"thih-1658923053242","7":[{"8":"优化思路二","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"zVcp-1658923053338","5":[{"2":"2","3":"v57l-1658923053336","7":[{"8":"该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"qD5K-1658923053547","4":{"l":"h1"},"5":[{"2":"2","3":"cblc-1658923053545","7":[{"8":"优先考虑覆盖索引","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"md9n-1658923053641","5":[{"2":"2","3":"RMgk-1658923053640","7":[{"8":"理解方式一:索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据;当能通过读取索引就可以得到想要的数据，那就不需要读取行了。"},{"8":"一个索引包含了满足查询结果的数据就叫做覆盖索引。","9":[{"2":"b"}]}]}]},{"3":"isto-1658970099855","4":{"version":1},"5":[{"2":"2","3":"KIhm-1658970099854","7":[{"8":"理解方式二:非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列(即建索引的字段正好是覆盖查询条件中所涉及的字段)。"}]}]},{"3":"DegW-1658923053737","5":[{"2":"2","3":"UAg1-1658923053736","7":[{"8":"简单说就是，索引列+主键包含SELECT到FROM之间查询的列。"}]}]},{"3":"2cef-1658970570720","4":{"wrap":false,"la":"","th":"default"},"5":[{"3":"NiVt-1658970570719","5":[{"2":"2","3":"DJi2-1658923053850","7":[{"8":"EXPLAIN SELECT * FROM student WHERE NAME LIKE '%abc ';#不使用索引，进行全表查询"}]}],"6":"cl"},{"3":"EmJi-1658970590332","5":[{"2":"2","3":"IhbG-1658970590329","7":[{"8":"EXPLAIN SELECT id,age,NAME,classid FROM student WHERE NAME LIKE '%abc ';"}]}],"6":"cl"},{"3":"cypN-1658970612576","5":[{"2":"2","3":"F3Uu-1658970612573","7":[{"8":"#使用覆盖索引，索引表不需要回表计算出成本更低"}]}],"6":"cl"}],"6":"cd"},{"3":"cWRO-1658925432191","4":{"l":"h3"},"5":[{"2":"2","3":"Wk6n-1658925432190","7":[{"8":"覆盖索引的利弊"}]}],"6":"h"},{"3":"ByF7-1658925432688","5":[{"2":"2","3":"sBld-1658925432686","7":[{"8":"好处："}]}]},{"3":"jfiq-1658925432797","5":[{"2":"2","3":"guCM-1658925432796","7":[{"8":"1."},{"8":"避免Innodb表进行索引的二次查询(回表)","9":[{"0":"#FFF2CC","2":"bg"}]}]}]},{"3":"KOp7-1658970844169","4":{"version":1},"5":[{"2":"2","3":"I1kW-1658970844168","7":[{"8":"Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据，在查找到相应的键值后，还需通过主键进行二次查询才能获取我们真实所需要的数据。在覆盖索引中，二级索引的键值中可以获取所要的数据，避免了对主键的二次查询，减少了IO操作，提升了查询效率。|"}]}]},{"3":"UyW5-1658970844171","4":{"version":1},"5":[{"2":"2","3":"Y5To-1658970844170","7":[{"8":"2.可以把随机Io变成顺序IO加快查询效率"}]}]},{"3":"GrU8-1658970844173","4":{"version":1},"5":[{"2":"2","3":"y7XM-1658970844172","7":[{"8":"由于覆盖索引是按键值的顺序存储的，对于I0密集型的范围查找来说，对比随机从磁盘读取每一行的数据Io要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序I0。"}]}]},{"3":"nbkj-1658970844175","4":{"version":1},"5":[{"2":"2","3":"7nSD-1658970844174","7":[{"8":"由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。"}]}]},{"3":"Y3Zc-1658925432892","5":[{"2":"2","3":"NItK-1658925432891","7":[{"8":"弊端:"}]}]},{"3":"ytJi-1658970862003","4":{"version":1},"5":[{"2":"2","3":"mzB1-1658970862002","7":[{"8":"索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是:业务DBA，或者称为业务数据架构师的工作。"}]}]},{"3":"MSWj-1658925433005","4":{"l":"h1"},"5":[{"2":"2","3":"ViNx-1658925433004","7":[{"8":"如何给字符串添加索引","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"fD60-1658973416372","4":{"wrap":false,"la":"","th":"default"},"5":[{"3":"Qs0W-1658973416371","5":[{"2":"2","3":"QOXA-1658925433101","7":[{"8":"mysql> alter table teacher add index index1(email); "}]}],"6":"cl"},{"3":"JIxD-1658973420414","5":[{"2":"2","3":"vdgV-1658973420413","7":[{"8":"#或"}]}],"6":"cl"},{"3":"pyyI-1658973420416","5":[{"2":"2","3":"3lVF-1658973420415","7":[{"8":"mysql> alter table teacher add index index2(email(6));"}]}],"6":"cl"}],"6":"cd"},{"3":"rza9-1658925433198","5":[{"2":"2","3":"nTqn-1658925433196","7":[{"8":"如果使用的是","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"index1","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"（即email整个字符串的索引结构），执行顺序是这样的：","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"IM2z-1658973429566","4":{"version":1},"5":[{"2":"2","3":"76GM-1658973429565","7":[{"8":"1. 从index1索引树找到满足索引值是’ ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"zhangssxyz@xxx.com ","9":[{"0":"#42b983","2":"c"},{"0":16,"2":"fs"}]},{"8":"’的这条记录，取得ID2的值；","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"NI7t-1658973429568","4":{"version":1},"5":[{"2":"2","3":"17fx-1658973429567","7":[{"8":"2. 到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集；","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"sn7c-1658973429571","4":{"version":1},"5":[{"2":"2","3":"IN1B-1658973429569","7":[{"8":"3. 取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email=' ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"zhangssxyz@xxx.com ","9":[{"0":"#42b983","2":"c"},{"0":16,"2":"fs"}]},{"8":"’的条件了，循环结束。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"aCMm-1658973429575","4":{"version":1},"5":[{"2":"2","3":"Mesz-1658973429574","7":[{"8":"这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"oJXN-1658973429577","4":{"version":1},"5":[{"2":"2","3":"J6g7-1658973429576","7":[{"8":"如果使用的是","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"index2","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"（即email(6)索引结构），执行顺序是这样的：","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"pG4Z-1658973429579","4":{"version":1},"5":[{"2":"2","3":"bF0i-1658973429578","7":[{"8":"1. 从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1； ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"qWco-1658973429581","4":{"version":1},"5":[{"2":"2","3":"ojO4-1658973429580","7":[{"8":"2. 到主键上查到主键值是ID1的行，判断出email的值不是’ ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"zhangssxyz@xxx.com ","9":[{"0":"#42b983","2":"c"},{"0":16,"2":"fs"}]},{"8":"’，这行记录丢弃；","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"T3eC-1658973429583","4":{"version":1},"5":[{"2":"2","3":"zMSj-1658973429582","7":[{"8":"3. 取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然后判断，这次值对了，将这行记录加入结果集；","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"qjJI-1658973429588","4":{"version":1},"5":[{"2":"2","3":"qQWI-1658973429587","7":[{"8":"4. 重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"rBar-1658973429590","4":{"version":1},"5":[{"2":"2","3":"X83O-1658973429589","7":[{"8":"也就是说","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"前面已经讲过区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"ny0I-1658925433293","5":[{"2":"2","3":"v0Ls-1658925433292","7":[{"8":"结论：","9":[{"0":"#777777","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"EHf0-1658973450244","4":{"version":1},"5":[{"2":"2","3":"aPlb-1658973450243","7":[{"8":"使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素。","9":[{"0":"#777777","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"gYAq-1658925433404","4":{"l":"h1"},"5":[{"2":"2","3":"tztP-1658925433403","7":[{"8":"索引下推（ICP）","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"e8om-1658925433500","5":[{"2":"2","3":"9uD7-1658925433499","7":[{"8":"Index Condition Pushdown(ICP)是MySQL 5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式。ICP可以减少存储引擎访问基表的次数以及MySQL服务器访问存储引擎的次数。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"Coct-1658973985811","4":{"wrap":false,"la":"","th":"default"},"5":[{"3":"0ge4-1658973985810","5":[{"2":"2","3":"pdwt-1658973980940","7":[{"8":"EXPLAIN SELECT * FROM s1 WHERE key1 > 'z' AND key1 LIKE '%a' ;"}]}],"6":"cl"},{"3":"8j8i-1658973995737","5":[{"2":"2","3":"XF96-1658973995736","7":[{"8":"#条件下推就是优化器通过索引筛选完key1>'z'之后，先对key1进行%a筛选，"}]}],"6":"cl"},{"3":"qb3U-1658974088466","5":[{"2":"2","3":"26Gp-1658974088464","7":[{"8":"#再去回表，筛选过后的查询节约了大量的IO"}]}],"6":"cl"},{"3":"FsAQ-1658974113455","5":[{"2":"2","3":"L0Y2-1658974113452","7":[{"8":"KEY zip_last_first ( `zipcode `, `lastname `, `firstname `)"}]}],"6":"cl"},{"3":"nVDZ-1658974124129","5":[{"2":"2","3":"DGE4-1658974124128","7":[{"8":"EXPLAIN SELECT * FROM people WHERE zipcode='000001'"}]}],"6":"cl"},{"3":"BkiO-1658974149433","5":[{"2":"2","3":"mL21-1658974149432","7":[{"8":"AND lastname LIKE '%张%"}]}],"6":"cl"},{"3":"nTve-1658974149435","5":[{"2":"2","3":"tn9x-1658974149434","7":[{"8":"AND address LIKE '%北京市%';"}]}],"6":"cl"},{"3":"6YdE-1658974149437","5":[{"2":"2","3":"gZ1O-1658974149436","7":[{"8":"#正常来说只用了联合索引的第一个。但是通过索引条件下推过滤第一个索引筛选出的条件"}]}],"6":"cl"}],"6":"cd"},{"3":"kxKr-1658925433597","5":[{"2":"2","3":"dW38-1658925433596","7":[{"8":"使用前后的成本差别","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"7el7-1658973920744","4":{"version":1},"5":[{"2":"2","3":"hDQJ-1658973920742","7":[{"8":"使用前，存储层多返回了需要被index filter过滤掉的整行记录","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"toZu-1658973920746","4":{"version":1},"5":[{"2":"2","3":"ssKw-1658973920745","7":[{"8":"使用ICP后，直接就去掉了不满足index filter条件的记录，省去了他们回表和传递到server层的成本。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"m1Go-1658973920748","4":{"version":1},"5":[{"2":"2","3":"gQof-1658973920747","7":[{"8":"ICP的 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"加速效果 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"取决于在存储引擎内通过 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"ICP","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"筛选 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"掉的数据的比例。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"NMyw-1658925433709","4":{"l":"h3"},"5":[{"2":"2","3":"2XvN-1658925433707","7":[{"8":"ICP","9":[{"0":"#34495e","2":"c"}]},{"8":"的使用条件 ","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"mPzJ-1658973945425","4":{"version":1},"5":[{"2":"2","3":"MOWi-1658973945424","7":[{"8":"① 只能用于二级索引(secondary index) ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"IY9y-1658973945427","4":{"version":1},"5":[{"2":"2","3":"UcBe-1658973945426","7":[{"8":"②explain显示的执行计划中type值（join 类型）为 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"range ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"、 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"ref ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"、 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"eq_ref ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"或者 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"ref_or_null ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"。 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"4aeU-1658973945430","4":{"version":1},"5":[{"2":"2","3":"zE74-1658973945429","7":[{"8":"③ 并非全部where条件都可以用ICP筛选，如果where条件的字段不在索引列中，还是要读取整表的记录","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"GlQa-1658973945432","4":{"version":1},"5":[{"2":"2","3":"gPOh-1658973945431","7":[{"8":"到server端做where过滤。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"J5cj-1658973945434","4":{"version":1},"5":[{"2":"2","3":"s61Q-1658973945433","7":[{"8":"④ ICP可以用于MyISAM和InnnoDB存储引擎","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"JHEp-1658973945436","4":{"version":1},"5":[{"2":"2","3":"Iqoe-1658973945435","7":[{"8":"⑤ MySQL 5.6版本的不支持分区表的ICP功能，5.7版本的开始支持。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"VczV-1658973945438","4":{"version":1},"5":[{"2":"2","3":"PwbZ-1658973945437","7":[{"8":"⑥ 当SQL使用覆盖索引时，不支持ICP优化方法。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"rPE2-1658925433901","4":{"l":"h3"},"5":[{"2":"2","3":"2LLr-1658925433899","7":[{"8":"ICP的开启和关闭"}]}],"6":"h"},{"3":"iZmd-1658980594564","4":{"wrap":false,"la":"","th":"default"},"5":[{"3":"Fv7e-1658980594563","5":[{"2":"2","3":"K2sc-1658925434011","7":[{"8":"#关闭索引下推"}]}],"6":"cl"},{"3":"QSWQ-1658980605536","5":[{"2":"2","3":"ZjNX-1658980605535","7":[{"8":"SET optimizer_switch = 'index_condition_pushdown=off' ;"}]}],"6":"cl"},{"3":"lLKQ-1658980605538","5":[{"2":"2","3":"bQdu-1658980605537","7":[{"8":"#打开索引下推"}]}],"6":"cl"},{"3":"P4jx-1658980605540","5":[{"2":"2","3":"0uD6-1658980605539","7":[{"8":"SET optimizer_switch = 'index_condition_pushdown=on ';"}]}],"6":"cl"}],"6":"cd"},{"3":"f1P3-1658925434107","4":{"l":"h3"},"5":[{"2":"2","3":"84Ic-1658925434105","7":[{"8":"ICP使用条件"}]}],"6":"h"},{"3":"f8lf-1658925434218","5":[{"2":"2","3":"JndD-1658925434217","7":[{"8":"1.如果表访问的类型为range、ref、eq_ref和ref_or_null 可以使用ICP"}]}]},{"3":"cJTM-1658981358860","5":[{"2":"2","3":"5tuS-1658981358858","7":[{"8":"2. ICP可以用于InnoDB和MyISAM表，包括分区表InnoDB和MyISAM表"}]}]},{"3":"tvQF-1658981355471","4":{"version":1},"5":[{"2":"2","3":"4dog-1658981355470","7":[{"8":"3．对于InnoDB表，ICP仅用于二级索引。ICP的目标是减少全行读取次数，从而减少I/o操作。"}]}]},{"3":"R526-1658981360805","4":{"version":1},"5":[{"2":"2","3":"H9ke-1658981360801","7":[{"8":"4．当sQL使用覆盖索引时，不支持ICP。因为这种情况下使用ICP不会减少I/O。"}]}]},{"3":"GU91-1658981355473","4":{"version":1},"5":[{"2":"2","3":"ZLCY-1658981355472","7":[{"8":"5.相关子查询的条件不能使用ICP"}]}]},{"3":"amz2-1658925434313","4":{"l":"h1"},"5":[{"2":"2","3":"ycbs-1658925434311","7":[{"8":"普通索引 ","9":[{"2":"b"},{"0":"#34495e","2":"c"}]},{"8":"vs ","9":[{"0":"#34495e","2":"c"}]},{"8":"唯一索引","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"wCkT-1658925434409","5":[{"2":"2","3":"tycm-1658925434407","7":[{"8":"假设，执行查询的语句是 select id from test where k=5。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"m6lp-1658982882506","4":{"li":"G4wg-1658982887871","lt":"unordered","ll":1},"5":[{"2":"2","3":"rx3E-1658982882505","7":[{"8":"对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"Y3N3-1658982882510","4":{"li":"G4wg-1658982887871","lt":"unordered","ll":1},"5":[{"2":"2","3":"YsyK-1658982882509","7":[{"8":"对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"a9zY-1658982882514","4":{"version":1},"5":[{"2":"2","3":"VpQ6-1658982882513","7":[{"8":"那么，这个不同带来的性能差距会有多少呢？答案是， ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"微乎其微 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"。 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"JvLM-1658925434519","4":{"l":"h3"},"5":[{"2":"2","3":"IqzI-1658925434518","7":[{"8":"更新过程","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"sFCW-1658925434614","5":[{"2":"2","3":"JLcJ-1658925434612","7":[{"8":"为了说明普通索引和唯一索引对更新语句性能的影响这个问题，介绍一下change buffer。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"12D2-1658982911562","4":{"version":1},"5":[{"2":"2","3":"OXhv-1658982911561","7":[{"8":"当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下， ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"InooDB","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"会将这些更新操作缓存在","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"change buffer","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"中 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"qmvZ-1658982911571","4":{"version":1},"5":[{"2":"2","3":"TxhM-1658982911570","7":[{"8":"将change buffer中的操作应用到原数据页，得到最新结果的过程称为 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"merge ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"。除了 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"访问这个数据页 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"会触发merge外，系统有 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"后台线程会定期 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"merge。在 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"数据库正常关闭（","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"shutdown","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"） ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"的过程中，也会执行merge操作。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"W9aK-1658982911579","4":{"version":1},"5":[{"2":"2","3":"LGj8-1658982911578","7":[{"8":"如果能够将更新操作先记录在change buffer， ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"减少读磁盘 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"避免占用内存 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"，提高内存利用率。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"nko1-1658982911584","4":{"version":1},"5":[{"2":"2","3":"1z4K-1658982911583","7":[{"8":"唯一索引的更新就不能使用","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"change buffer ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"，实际上也只有普通索引可以使用。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"e2n6-1658983003970","4":{"l":"h3"},"5":[{"2":"2","3":"TwHW-1658983003969","7":[{"8":"change buffer","9":[{"0":"#34495e","2":"c"}]},{"8":"的使用场景 ","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"Ade3-1658925434821","5":[{"2":"2","3":"7CXL-1658925434819","7":[{"8":"1. 普通索引和唯一索引应该怎么选择？其实，这两类索引在查询能力上是没差别的，主要考虑的是对 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"更新性能 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"的影响。所以，建议你 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"尽量选择普通索引 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"。 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"x4AO-1658983068675","4":{"version":1},"5":[{"2":"2","3":"KM4I-1658983068674","7":[{"8":"2. 在实际使用中会发现， ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"普通索引 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"和 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"change buffer ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"的配合使用，对于 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"数据量大 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"的表的更新优化还是很明显的。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"X9LA-1658983068679","4":{"version":1},"5":[{"2":"2","3":"h8EG-1658983068678","7":[{"8":"3. 如果所有的更新后面，都马上 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"伴随着对这个记录的查询 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"，那么你应该 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"关闭","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"change buffer ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"。而在其他情况下，change buffer都能提升更新性能。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"iZVq-1658983068684","4":{"version":1},"5":[{"2":"2","3":"LyPo-1658983068683","7":[{"8":"4. 由于唯一索引用不上change buffer的优化机制，因此如果 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"业务可以接受 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"，从性能角度出发建议优先考虑非唯一索引。但是如果\"业务可能无法确保\"的情况下，怎么处理呢？","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"HbFI-1658983078231","4":{"version":1},"5":[{"2":"2","3":"zAyU-1658983078229","7":[{"8":"首先， ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"业务正确性优先 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"。我们的前提是“业务代码已经保证不会写入重复数据”的情况下，讨论性能问题。如果业务不能保证，或者业务就是要求数据库来做约束，那么没得选，必须创建唯一索引。这种情况下，本节的意义在于，如果碰上了大量插入数据慢、内存命中率低的时候，给你多提供一个排查思路。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"Zot6-1658983083338","4":{"version":1},"5":[{"2":"2","3":"Kycy-1658983083335","7":[{"8":"然后，在一些“ ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"归档库 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"”的场景，你是可以考虑使用唯一索引的。比如，线上数据只需要保留半年，然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。要提高归档效率，可以考虑把表里面的唯一索引改成普通索引。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"qUcV-1658925434915","4":{"l":"h1"},"5":[{"2":"2","3":"3hbV-1658925434914","7":[{"8":"其它查询优化策略","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"x8TD-1658925435010","4":{"l":"h3"},"5":[{"2":"2","3":"wQlj-1658925435008","7":[{"8":"EXISTS ","9":[{"0":"#34495e","2":"c"}]},{"8":"和 ","9":[{"2":"b"},{"0":"#34495e","2":"c"}]},{"8":"IN ","9":[{"0":"#34495e","2":"c"}]},{"8":"的区分","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"Wrlh-1658925435122","5":[{"2":"2","3":"SEZF-1658925435121","7":[{"8":"索引是个前提，其实选择与否还是要看表的大小。你可以将选择的标准理解为小表驱动大表。在这种方式下效率是最高的。"}]}]},{"3":"eB6H-1658990661883","4":{"wrap":false,"la":"","th":"default"},"5":[{"3":"kng1-1658990661882","5":[{"2":"2","3":"0zB6-1658925435216","7":[{"8":"SELECT *FROM A WHERE cc IN (SELECT cc FROM B)"}]}],"6":"cl"},{"3":"7OS4-1658990670818","5":[{"2":"2","3":"zsa6-1658990670817","7":[{"8":"SELECT *FROM A WHERE EXISTS ( SELECT cc FROM B WHERE B.cc=A.cc)"}]}],"6":"cl"}],"6":"cd"},{"3":"DV0V-1658925435328","5":[{"2":"2","3":"sg6k-1658925435327","7":[{"8":"当A小于B时，用EXISTS。因为EXISTS的实现，相当于外表循环，实现的逻辑类似于："}]}]},{"3":"ljQy-1658990714906","4":{"version":1,"u":"https://note.youdao.com/yws/res/e/WEBRESOURCE57c3ecd18a8a570b6f04b97833aecfae","w":316,"h":95},"6":"im"},{"3":"ppxo-1658990694025","5":[{"2":"2","3":"D3oz-1658990694023","7":[{"8":"当B小于A时用IN，因为实现的逻辑类似于:"}]}]},{"3":"oHIU-1658990718904","4":{"version":1,"u":"https://note.youdao.com/yws/res/6/WEBRESOURCEf5e9a67adf1b283d1234b60e1368e5e6","w":311,"h":122},"6":"im"},{"3":"J4oS-1658925435518","4":{"l":"h3"},"5":[{"2":"2","3":"h5VD-1658925435516","7":[{"8":"COUNT(*)","9":[{"0":"#34495e","2":"c"}]},{"8":"与","9":[{"2":"b"},{"0":"#34495e","2":"c"}]},{"8":"COUNT(","9":[{"0":"#34495e","2":"c"}]},{"8":"具体字段","9":[{"2":"b"},{"0":"#34495e","2":"c"}]},{"8":")","9":[{"0":"#34495e","2":"c"}]},{"8":"效率","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"NPKx-1658925435629","5":[{"2":"2","3":"d8hv-1658925435628","7":[{"8":"问:在MySQL中统计数据表的行数，可以使用三种方式: SELECT COUNT()、SELECT COUNT(1)和SELECTCOUNT(具体字段)，使用这三者之间的查询效率是怎样的?"}]}]},{"3":"qjRl-1658990919554","5":[{"2":"2","3":"MZoQ-1658990919551","7":[{"8":"前提:如果你要统计的是某个字段的非空数据行数，则另当别论，毕竟比较执行效率的前提是结果一样才可以。"}]}]},{"3":"ph6S-1658990927743","5":[{"2":"2","3":"2ZtW-1658990927741","7":[{"8":"环节1:COUNT(*)和COUNT(1)都是对所有结果进行COUNT，COUNT(*)和COUNT(1)本质上并没有区别(二者执行时间可能略有差别，不过你还是可以把它俩的执行效率看成是相等的)。如果有WHERE子句则是对所有符合筛选条件的数据行进行统计;如果没有WHERE子句，则是对数据表的数据行数进行统计。"}]}]},{"3":"Yhxv-1658990895143","4":{"version":1},"5":[{"2":"2","3":"jIeY-1658990895142","7":[{"8":"环节2:如果是MylISAM存储引擎，统计数据表的行数只需要0(1)的复杂度，这是因为每张MylISAM的数据表都有一个meta信息存储了row_count值，而一致性则由表级锁来保证。"}]}]},{"3":"a42E-1658925435724","5":[{"2":"2","3":"cuIb-1658925435722","7":[{"8":"如果是InnoDB存储引擎，因为InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MylSAM一样，维护一个row_count变量，因此需要采用扫描全表，是o(n)的复杂度，进行循环＋计数的方式来完成统计"}]}]},{"3":"0wLf-1658990978324","4":{"version":1},"5":[{"2":"2","3":"3Eg9-1658990978323","7":[{"8":"环节3:在InnoDB引擎中，如果采用COUNT(具体字段)来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引(非聚簇索引)。对于COUNT(*)和COUNT(1)来说，它们不需要查找具体的行，只是统计行数，系统会自动采用占用空间更小的二级索引来进行统计。"}]}]},{"3":"9vmT-1658925435819","5":[{"2":"2","3":"gQBj-1658925435818","7":[{"8":"如果有多个二级索引，会使用key_len小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。"}]}]},{"3":"x4kp-1658925435931","4":{"l":"h3"},"5":[{"2":"2","3":"udHy-1658925435930","7":[{"8":"关于","9":[{"2":"b"},{"0":"#34495e","2":"c"}]},{"8":"SELECT(*)","9":[{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"b0wx-1658925436024","5":[{"2":"2","3":"Wsnd-1658925436023","7":[{"8":"在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT <字段列表> 查询。原因：","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"T8cJ-1658991179763","4":{"version":1},"5":[{"2":"2","3":"3h5t-1658991179762","7":[{"8":"① MySQL 在解析的过程中，会通过 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"查询数据字典 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"将\"*\"按序转换成所有列名，这会大大的耗费资源和时间。② 无法使用 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"覆盖索引 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]}]}]},{"3":"AiSW-1658991188412","4":{"l":"h3"},"5":[{"2":"2","3":"Tk0M-1658991188411","7":[{"8":"LIMIT 1 ","9":[{"0":"#34495e","2":"c"}]},{"8":"对优化的影响","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"Aflf-1658925436327","5":[{"2":"2","3":"luc8-1658925436326","7":[{"8":"针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"LIMIT 1 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"65pg-1658991212472","4":{"version":1},"5":[{"2":"2","3":"ouRX-1658991212471","7":[{"8":"如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"LIMIT 1 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"了。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"bNoe-1658925436439","4":{"l":"h3"},"5":[{"2":"2","3":"75J9-1658925436437","7":[{"8":"多使用","9":[{"2":"b"},{"0":"#34495e","2":"c"}]},{"8":"COMMIT","9":[{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"MImk-1658925436533","5":[{"2":"2","3":"RNNy-1658925436532","7":[{"8":"只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放的资源而减少。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"V5LD-1658925436630","5":[{"2":"2","3":"euLu-1658925436629","7":[{"8":"COMMIT 所释放的资源：","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"L4FP-1658991246234","4":{"li":"KzJE-1658991249281","lt":"unordered","ll":1},"5":[{"2":"2","3":"rohm-1658991246233","7":[{"8":"回滚段上用于恢复数据的信息","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"I322-1658991246236","4":{"li":"KzJE-1658991249281","lt":"unordered","ll":1},"5":[{"2":"2","3":"rBQZ-1658991246235","7":[{"8":"被程序语句获得的锁","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"hIeM-1658991246238","4":{"li":"KzJE-1658991249281","lt":"unordered","ll":1},"5":[{"2":"2","3":"bUj1-1658991246237","7":[{"8":"redo / undo log buffer 中的空间","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"TopS-1658991246240","4":{"li":"KzJE-1658991249281","lt":"unordered","ll":1},"5":[{"2":"2","3":"AKCj-1658991246239","7":[{"8":"管理上述 3 种资源中的内部花费","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"}],"title":"","__compress__":true}