{"2":"1","3":"Ju9C-1621846617594","4":{"version":1,"incompatibleVersion":0,"fv":"0"},"5":[{"3":"3060-1621846615933","5":[{"2":"2","3":"p5PQ-1621846617594","7":[{"8":"事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"tuWT-1659157173404","4":{"li":"VubO-1659157182202","lt":"unordered","ll":1},"5":[{"2":"2","3":"Kgcc-1659157173403","7":[{"8":"事务的隔离性由 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"锁机制 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"实现。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"Czq4-1659157173406","4":{"li":"VubO-1659157182202","lt":"unordered","ll":1},"5":[{"2":"2","3":"prCV-1659157173405","7":[{"8":"而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"ADYX-1659157173408","4":{"li":"VubO-1659157182202","lt":"unordered","ll":2},"5":[{"2":"2","3":"0fGu-1659157173407","7":[{"8":"REDO LOG 称为 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"重做日志 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"qeAb-1659157173412","4":{"li":"VubO-1659157182202","lt":"unordered","ll":2},"5":[{"2":"2","3":"Z400-1659157173411","7":[{"8":"UNDO LOG 称为 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"回滚日志 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"jdiR-1659157173414","5":[{"2":"2","3":"65Pq-1659157173413","7":[{"8":"有的DBA或许会认为 UNDO 是 REDO 的逆过程，其实不然。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"iEzE-1659157163929","4":{"li":"rLf0-1659157233875","lt":"unordered","ll":1},"5":[{"2":"2","3":"TqWt-1659157163928","7":[{"8":"redo log:是存储引擎层(innodb)生成的日志，记录的是\"物理级别\"上的页修改操作，比如页号xx、偏移量yyy、写入了'zzz'数据。主要为了保证数据的可靠性;"}]}],"6":"l"},{"3":"Bpru-1659157203861","4":{"li":"rLf0-1659157233875","lt":"unordered","ll":1},"5":[{"2":"2","3":"03DL-1659157203860","7":[{"8":"undo log:是存储引擎层(innodb)生成的日志，记录的是逻辑操作日志，比如对某一行数据进行了INSERT语句操作，那么undo log就记录一条与之相反的DELETE操作。主要用于事务的回滚(undo log记录的是每个修改操作的逆操作)和一致性非锁定读(undo log回滚行记录到某种特定的版本---MVCC，即多版本并发控制)。"}]}],"6":"l"},{"3":"ikvZ-1659157164429","4":{"l":"h1"},"5":[{"2":"2","3":"zZU3-1659157164426","7":[{"8":"redo","9":[{"0":"#34495e","2":"c"}]},{"8":"日志","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"TPLy-1659157164533","5":[{"2":"2","3":"2kEh-1659157164532","7":[{"8":"InnoDB存储引擎是以页为单位来管理存储空间的。在真正访问页面之前，需要把在磁盘上的页缓存到内存中的Buffer Pool之后才可以访问。所有的变更都必须先更新缓冲池中的数据，然后缓冲池中的脏页会以一定的频率被刷入磁盘（ checkPoint机制），通过缓冲池来优化CPU和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。"}]}]},{"3":"zsF2-1659157164632","4":{"l":"h3"},"5":[{"2":"2","3":"MDfp-1659157164630","7":[{"8":"为什么需要","9":[{"2":"b"},{"0":"#34495e","2":"c"}]},{"8":"REDO","9":[{"0":"#34495e","2":"c"}]},{"8":"日志","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"rs8m-1659157164729","5":[{"2":"2","3":"iTmc-1659157164727","7":[{"8":"一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"并不是每次变更的时候就触发 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"的，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"0IRk-1659158048211","4":{"version":1},"5":[{"2":"2","3":"LYOW-1659158048210","7":[{"8":"另一方面，事务包含 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"持久性 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"UFlM-1659158048215","4":{"version":1},"5":[{"2":"2","3":"Z5MK-1659158048214","7":[{"8":"那么如何保证这个持久性呢？ ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"一个简单的做法 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题：","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"2OHw-1659158074146","4":{"li":"GH5Y-1659158121943","lt":"unordered","ll":1},"5":[{"2":"2","3":"VbO0-1659158074144","7":[{"8":"修改量与刷新磁盘工作量严重不成比例","9":[{"0":"#A00E0EFF","2":"c"}]},{"8":"。有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在InnoDB中是以页为单位来进行磁盘lo的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太小题大做了。"}]}],"6":"l"},{"3":"tmUa-1659158085513","4":{"li":"GH5Y-1659158121943","lt":"unordered","ll":1},"5":[{"2":"2","3":"GVk1-1659158085512","7":[{"8":"随机Io刷新较慢","9":[{"0":"#A00E0EFF","2":"c"}]},{"8":"。一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Buffer Pool中的页面刷新到磁盘时，需要进行很多的随机IO，随机Io比顺序Io要慢，尤其对于传统的机械硬盘来说。"}]}],"6":"l"},{"3":"UlRP-1659158048219","4":{"version":1},"5":[{"2":"2","3":"XOoF-1659158048218","7":[{"8":"另一个解决的思路 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"修改 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"了哪些东西 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"记录一下 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"就好。比如，某个事务将系统表空间中 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"第","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"10","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"号 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"页面中偏移量为 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"100 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"处的那个字节的值 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"1 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"改成 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"2 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"lnIv-1659157164840","5":[{"2":"2","3":"gMYt-1659157164838","7":[{"8":"InnoDB引擎的事务采用了WAL技术(Write-Ahead Logging )，这种技术的思想就是先写日志，再写磁盘，只有日志写入成功，才算事务提交成功，这里的日志就是redo log。当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证ACID中的D，这就是redo log的作用。"}]}]},{"3":"xgIx-1659158283258","4":{"l":"h3"},"5":[{"2":"2","3":"h8AL-1659158283257","7":[{"8":"REDO","9":[{"0":"#34495e","2":"c"}]},{"8":"日志的好处、特点 ","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"Gs0U-1659157165028","5":[{"2":"2","3":"sR4a-1659157165027","7":[{"8":"1. ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"好处","9":[{"2":"b"},{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"Ty1P-1659158293339","4":{"version":1},"5":[{"2":"2","3":"4UFX-1659158293338","7":[{"8":"redo","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"日志降低了刷盘频率","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"kGqA-1659158293341","4":{"version":1},"5":[{"2":"2","3":"uC1R-1659158293340","7":[{"8":"redo","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"日志占用的空间非常小","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"boX7-1659158293343","4":{"version":1},"5":[{"2":"2","3":"Sl9O-1659158293342","7":[{"8":"2. ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"特点","9":[{"2":"b"},{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"iYlH-1659158293345","4":{"version":1},"5":[{"2":"2","3":"KM50-1659158293344","7":[{"8":"redo","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"日志是顺序写入磁盘的","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"7s4s-1659162105952","4":{"version":1},"5":[{"2":"2","3":"M1Rw-1659162105950","7":[{"8":"在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序Io，效率比随机Io快。"}]}]},{"3":"prVy-1659158293347","4":{"version":1},"5":[{"2":"2","3":"PYCD-1659158293346","7":[{"8":"事务执行过程中，","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"redo log","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"不断记录","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"mm21-1659162107615","4":{"version":1},"5":[{"2":"2","3":"gJ49-1659162107613","7":[{"8":"redo log跟bin log的区别,redo log是存储引擎层产生的，而bin log是数据库层产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo logl顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中。"}]}]},{"3":"C663-1659158303144","4":{"l":"h3"},"5":[{"2":"2","3":"lEVT-1659158303143","7":[{"8":"redo","9":[{"0":"#34495e","2":"c"}]},{"8":"的组成","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"QFEQ-1659157171421","5":[{"2":"2","3":"OCso-1659157171420","7":[{"8":"Redo log可以简单分为以下两个部分：","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"Noon-1659162164686","4":{"li":"UgSG-1659162187089","lt":"unordered","ll":1},"5":[{"2":"2","3":"s1nV-1659162164685","7":[{"8":"重做日志的缓冲 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"(redo log buffer) ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"，保存在内存中，是易失的","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"sXMI-1659162241955","5":[{"2":"2","3":"wIdb-1659162241953","7":[{"8":"在服务器启动时就向操作系统申请了一大片称之为redo log buffer的连续内存空间，翻译成中文就是redo日志缓冲区。这片内存空间被划分成若干个连续的redo log block。一个redo log block占用512字节大"}]}]},{"3":"zgyJ-1659162265912","4":{"version":1,"u":"https://note.youdao.com/yws/res/0/WEBRESOURCEcdfafd3c244927b0b7ebb5374b9ae1f0","w":582,"h":221},"6":"im"},{"3":"eiJS-1659157171938","5":[{"2":"2","3":"HdxO-1659157171937","7":[{"8":"参数设置：","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"innodb_log_buffer_size","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"： ","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"CHiQ-1659162169954","4":{"version":1},"5":[{"2":"2","3":"ddMZ-1659162169953","7":[{"8":"redo log buffer 大小，默认 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"16M ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"，最大值是4096M，最小值为1M。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"I81n-1659162177193","4":{"wrap":false,"la":"","th":"default"},"5":[{"3":"SDjW-1659162177192","5":[{"2":"2","3":"QuB8-1659157172032","7":[{"8":"show variables like '%innodb_log_buffer_size%'; "}]}],"6":"cl"}],"6":"cd"},{"3":"QjjE-1659157172130","4":{"li":"ABCB-1659162184996","lt":"unordered","ll":1},"5":[{"2":"2","3":"NMZZ-1659157172128","7":[{"8":"重做日志文件 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"(redo log file) ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"，保存在硬盘中，是持久的。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"wh9P-1659162443915","4":{"version":1,"u":"https://note.youdao.com/yws/res/e/WEBRESOURCE1e527873825e649309b24394fa65c3de","w":582,"h":55},"6":"im"},{"3":"wOtd-1659157656679","4":{"l":"h3"},"5":[{"2":"2","3":"PuS0-1659157656678","7":[{"8":"redo","9":[{"0":"#34495e","2":"c"}]},{"8":"的整体流程","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"45b4-1659163498963","4":{"version":1,"u":"https://note.youdao.com/yws/res/b/WEBRESOURCE6803a975c73e3f21c2f2c85da8d18ddb","w":582,"h":204},"6":"im"},{"3":"Vqn1-1659157656885","5":[{"2":"2","3":"rdjv-1659157656883","7":[{"8":"第","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"1","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]}]}]},{"3":"SLpr-1659163512128","4":{"version":1},"5":[{"2":"2","3":"fRvj-1659163512127","7":[{"8":"第","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"2","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"步：生成一条重做日志并写入","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"redo log buffer","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"，记录的是数据被修改后的值 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]}]}]},{"3":"oHMz-1659163512131","4":{"version":1},"5":[{"2":"2","3":"TNO2-1659163512130","7":[{"8":"第","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"3","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"步：当事务","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"commit","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"时，将","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"redo log buffer","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"中的内容刷新到 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"redo log file","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"，对 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"redo log file","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"采用追加写的方式 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]}]}]},{"3":"tkdK-1659163512136","4":{"version":1},"5":[{"2":"2","3":"SXkJ-1659163512135","7":[{"8":"第","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"4","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"步：定期将内存中修改的数据刷新到磁盘中","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]}]}]},{"3":"zPRr-1659157656979","5":[{"2":"2","3":"qWln-1659157656977","7":[{"8":"体会：Write-Ahead Log(预先日志持久化)：在持久化一个数据页之前，先将内存中相应的日志页持久化。","9":[{"0":"#777777","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"qPYj-1659163740777","4":{"l":"h3"},"5":[{"2":"2","3":"OY6r-1659163740776","7":[{"8":"redo log","9":[{"0":"#34495e","2":"c"}]},{"8":"的刷盘策略 ","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"mTm7-1659157657189","5":[{"2":"2","3":"aXSs-1659157657188","7":[{"8":"redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"一定的频率 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"刷入到真正的redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"abg1-1659163803978","4":{"version":1,"u":"https://note.youdao.com/yws/res/1/WEBRESOURCE78603da274964656ee9b49241ad95721","w":582,"h":348},"6":"im"},{"3":"yAtX-1659157172240","5":[{"2":"2","3":"UTUh-1659157172239","7":[{"8":"注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"文件系统缓存 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"（page cache）中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"9J8P-1659157172336","5":[{"2":"2","3":"Eu0H-1659157172335","7":[{"8":"针对这种情况，InnoDB给出 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"innodb_flush_log_at_trx_commit ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"69az-1659163812186","4":{"li":"iMCq-1659163833409","lt":"unordered","ll":1},"5":[{"2":"2","3":"WA0N-1659163812183","7":[{"8":"设置为","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"0 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"Yl5l-1659163812706","4":{"li":"iMCq-1659163833409","lt":"unordered","ll":1},"5":[{"2":"2","3":"TXFK-1659163812704","7":[{"8":"设置为","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"1 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"：表示每次事务提交时都将进行同步，刷盘操作（ ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"默认值 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"） ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"tzd6-1659163830734","4":{"li":"iMCq-1659163833409","lt":"unordered","ll":1},"5":[{"2":"2","3":"nS3U-1659163830733","7":[{"8":"设置为","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"2 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"DJTY-1659163812793","5":[{"2":"2","3":"HZ7r-1659163812791","7":[{"8":"另外，InnoDB存储引擎有一个后台线程，每隔1秒，就会把 redo log buffer 中的内容写到文件系统缓存( page cache )，然后调用刷盘操作。"}]}]},{"3":"70vz-1659163812889","4":{"l":"h3"},"5":[{"2":"2","3":"agPR-1659163812888","7":[{"8":"不同刷盘策略演示","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"QF5N-1659164640098","4":{"version":1,"u":"https://note.youdao.com/yws/res/0/WEBRESOURCEdf98894a54e96357f470782446f25ba0","w":582,"h":451},"6":"im"},{"3":"PiXF-1659164653062","4":{"version":1,"u":"https://note.youdao.com/yws/res/0/WEBRESOURCE6a23f9c2fa9d414ad185c580662aa1a0","w":582,"h":441},"6":"im"},{"3":"0hm3-1659164662064","4":{"version":1,"u":"https://note.youdao.com/yws/res/2/WEBRESOURCE2e8b5354660982483f4d3874f45036f2","w":582,"h":451},"6":"im"},{"3":"nXLK-1659165855647","5":[{"2":"2","3":"P69x-1659165855648"}]},{"3":"OPVD-1659164879166","4":{"version":1,"u":"https://note.youdao.com/yws/res/2/WEBRESOURCE9c9fec82af15b382b2d2e338da692022","w":582,"h":130},"6":"im"},{"3":"S0xA-1659165415415","4":{"l":"h3"},"5":[{"2":"2","3":"eWcj-1659165415414","7":[{"8":"写入","9":[{"2":"b"},{"0":"#34495e","2":"c"}]},{"8":"redo log buffer ","9":[{"0":"#34495e","2":"c"}]},{"8":"过程 （了解）","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"9TYU-1659163813462","5":[{"2":"2","3":"znLq-1659163813461","7":[{"8":"MysQL把对底层页面中的一次原子访问的过程称之为一个Mini-Transaction，简称mtr，比如向某个索引对应的B+树中插入一条记录的过程就是一个Mini-Transaction。一个所谓的mtr可以包含一组redo日志，在进行崩溃恢复时这一组redo日志作为一个不可分割的整体。"}]}]},{"3":"re9f-1659165446437","4":{"version":1},"5":[{"2":"2","3":"Y032-1659165446436","7":[{"8":"一个事务可以包含若干条语句，每一条语句其实是由若干个mtr组成，每一个mtr又可以包含若干条redo日志，画个图表示它们的关系就是这样:"}]}]},{"3":"zuUl-1659165460156","4":{"version":1,"u":"https://note.youdao.com/yws/res/5/WEBRESOURCEc5216ee7250b70149aeaed60b1d9b765","w":315,"h":273},"6":"im"},{"3":"JbMV-1659163813642","4":{"l":"h5"},"5":[{"2":"2","3":"6zaA-1659163813640","7":[{"8":"redo ","9":[{"0":"#34495e","2":"c"}]},{"8":"日志写入","9":[{"2":"b"},{"0":"#34495e","2":"c"}]},{"8":"log buffer","9":[{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"csQH-1659164853028","5":[{"2":"2","3":"6x1b-1659164853024","7":[{"8":"向log buffer中写入redo日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写。当我们想往log buffer中写入redo日志时，第一个遇到的问题就是应该写在哪个block的哪个偏移量处，所以InnoDB的设计者特意提供了一个称之为buf_free的全局变量，该变量指明后续写入的redo日志应该写入到log buffer中的哪个位置，如图所示:"}]}]},{"3":"hxqA-1659165582186","4":{"version":1,"u":"https://note.youdao.com/yws/res/2/WEBRESOURCE76c7f19e0bc05080ae35e53ced889392","w":582,"h":260},"6":"im"},{"3":"T2Xc-1659164853653","5":[{"2":"2","3":"7vfs-1659164853651","7":[{"8":"一个mti的行过程中可能产生若干条redo日志，这些redo日志是一个不可分割的组，所以其实并不是每生成一条redo日志，就将其插入到log buffer中，而是每个mtr运行过程中产生的日志先暂时存到一个地方，当该mtr结束的时候，将过程中产生的一组redo日志再全部复制到log buffer中。"}]}]},{"3":"dFcG-1659164853760","5":[{"2":"2","3":"PhB8-1659164853758","7":[{"8":"不同的事务可能是并发执行的，所以T1、T2之间的mtr可能是交替执行的。每当一个mtr执行完成时，伴随该mtr生成的一组redo日志就需要被复制到log buffer中，也就是说不同事务的mtr可能是交替写入log buffer的，我们画个示意图(为了美观，我们把一个mtr中产生的所有的redo日志当作一个整体来画)∶"}]}]},{"3":"Ktpz-1659165664400","4":{"version":1,"u":"https://note.youdao.com/yws/res/6/WEBRESOURCE32a585d4aac866446dbb557e1ba68da6","w":582,"h":215},"6":"im"},{"3":"lmmw-1659164854073","4":{"l":"h5"},"5":[{"2":"2","3":"NRZp-1659164854071","7":[{"8":"redo log block","9":[{"0":"#34495e","2":"c"}]},{"8":"的结构图","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"7qIY-1659165715713","4":{"version":1},"5":[{"2":"2","3":"DSIT-1659165715714","7":[{"8":"为什么一个block设计成512字节?"}]}]},{"3":"tmpG-1659165715970","4":{"version":1},"5":[{"2":"2","3":"wHUR-1659165715969","7":[{"8":"这个和磁盘的扇区有关，机械磁盘默认的扇区就是512字节，如果你要写入的数据大于512字节，那么要写入的扇区肯定不止一个，这时就要涉及到盘片的转动，找到下一个扇区，假设现在需要写入两个扇区A和B，如果扇区A写入成功，而扇区B写入失败，那么就会出现非原子性的写入，而如果每次只写入和扇区的大小一样的512字节，那么每次的写入都是原子性的。"}]}]},{"3":"80yR-1659165699245","4":{"version":1,"u":"https://note.youdao.com/yws/res/d/WEBRESOURCE5d7f742727b9473591d789381a40afed","w":582,"h":342},"6":"im"},{"3":"o3PA-1659164854268","4":{"l":"h3"},"5":[{"2":"2","3":"mWDX-1659164854265","7":[{"8":"redo log file（了解）","9":[{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"yPpj-1659165688141","4":{"l":"h5"},"5":[{"2":"2","3":"ZLGt-1659165688138","7":[{"8":"相关参数设置 ","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"cACd-1659165859818","4":{"version":1},"5":[{"2":"2","3":"U3lX-1659165859817","7":[{"8":"innodb_log_group_home_dir ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"：指定 redo log 文件组所在的路径，默认值为 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"./ ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"，表示在数据库的数据目录下。MySQL的默认数据目录（ ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"var/lib/mysql ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"）下默认有两个名为 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"ib_logfile0 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"和 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"ib_logfile1 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志文件位置还可以修改。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"cTBI-1659165859830","4":{"version":1},"5":[{"2":"2","3":"P0Z3-1659165859829","7":[{"8":"innodb_log_files_in_group","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"：指明redo log file的个数，命名方式如：ib_logfile0，iblogfile1... iblogfilen。默认2个，最大100个。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"xlHp-1659165688658","5":[{"2":"2","3":"ZeZT-1659165688656","7":[{"8":"innodb_flush_log_at_trx_commit","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"：控制 redo log 刷新到磁盘的策略，默认为1。 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"wpNN-1659165881948","4":{"version":1},"5":[{"2":"2","3":"A1kN-1659165881947","7":[{"8":"innodb_log_file_size","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"：单个 redo log 文件设置大小，默认值为 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"48M ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"。最大值为512G，注意最大值指的是整个 redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size ）不能大于最大值512G。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"0wMA-1659165890818","4":{"l":"h5"},"5":[{"2":"2","3":"Uzqx-1659165890817","7":[{"8":"日志文件组","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"rkXD-1659165688876","4":{"l":"h5"},"5":[{"2":"2","3":"Va3q-1659165688874","7":[{"8":"checkpoint","9":[{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"pGWJ-1659165909237","4":{"l":"h1"},"5":[{"2":"2","3":"eV3V-1659165909236","7":[{"8":"Undo","9":[{"0":"#34495e","2":"c"}]},{"8":"日志","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"CCvj-1659165689085","5":[{"2":"2","3":"XQjY-1659165689084","7":[{"8":"redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"更新数据 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"的 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"前置操作 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"其实是要先写入一个 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"undo log ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"。 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"4WvB-1659165689179","4":{"l":"h3"},"5":[{"2":"2","3":"P3bQ-1659165689178","7":[{"8":"如何理解","9":[{"2":"b"},{"0":"#34495e","2":"c"}]},{"8":"Undo","9":[{"0":"#34495e","2":"c"}]},{"8":"日志","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"6AFR-1659165689386","5":[{"2":"2","3":"e8uY-1659165689385","7":[{"8":"事务需要保证 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"原子性 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"Uyq0-1659167246414","4":{"li":"tOD5-1659167256785","lt":"unordered","ll":1},"5":[{"2":"2","3":"drND-1659167246413","7":[{"8":"情况一：事务执行过程中可能遇到各种错误，比如 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"服务器本身的错误 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"， ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"操作系统错误 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"，甚至是突然 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"断电 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"导致的错误。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"gYoG-1659167246418","4":{"li":"tOD5-1659167256785","lt":"unordered","ll":1},"5":[{"2":"2","3":"Z8DJ-1659167246417","7":[{"8":"情况二：程序员可以在事务执行过程中手动输入 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"ROLLBACK ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"语句结束当前事务的执行。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"YALO-1659167252888","4":{"version":1},"5":[{"2":"2","3":"V6mB-1659167252885","7":[{"8":"以上情况出现，我们需要把数据改回原先的样子，这个过程称之为 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"回滚 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"原子性 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"要求。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"eXdd-1659165689483","5":[{"2":"2","3":"0RVy-1659165689481","7":[{"8":"每当我们要对一条记录做改动时(这里的改动可以指INSERT、DELETE、UPDATE)，都需要\"留一手\"—―把回滚时所需的东西记下来。比如:"}]}]},{"3":"dC44-1659167639460","4":{"li":"eFBd-1659167648973","lt":"unordered","ll":1},"5":[{"2":"2","3":"OBjg-1659167639459","7":[{"8":"你插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。(对于每个INSERT，InnoDB存储引擎会完成一个DELETE)"}]}],"6":"l"},{"3":"eCUi-1659167639462","4":{"li":"eFBd-1659167648973","lt":"unordered","ll":1},"5":[{"2":"2","3":"q7RY-1659167639461","7":[{"8":"你删除了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。(对于每个DELETE，InnoDB存储引擎会执行一个INSERT)"}]}],"6":"l"},{"3":"ETsB-1659167639464","4":{"li":"eFBd-1659167648973","lt":"unordered","ll":1},"5":[{"2":"2","3":"v7bO-1659167639463","7":[{"8":"你修改了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。(对丑每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE，将修改前的行放回去)"}]}],"6":"l"},{"3":"pgws-1659167639466","4":{"version":1},"5":[{"2":"2","3":"PLxw-1659167639465","7":[{"8":"MysQL把这些为了回滚而记录的这些内容称之为撤销日志或者回滚日志(即undo log)。注意，由于查询操作( SELECT ）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo日志。"}]}]},{"3":"xZlt-1659165689578","5":[{"2":"2","3":"VgjM-1659165689576","7":[{"8":"此外，undo log 会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。"}]}]},{"3":"vM99-1659167748629","4":{"l":"h3"},"5":[{"2":"2","3":"kjlJ-1659167748628","7":[{"8":"Undo","9":[{"0":"#34495e","2":"c"}]},{"8":"日志的作用","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"kgxv-1659167265700","5":[{"2":"2","3":"1Arj-1659167265698","7":[{"8":"作用","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"1","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"：回滚数据","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"U0gt-1659168454532","5":[{"2":"2","3":"yZVG-1659168454530","7":[{"8":"用户对undo日志可能有误解:undo用于将数据库物理地恢复到执行语句或事务之前的样子。但事实并非如此。undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。"}]}]},{"3":"TUj2-1659168452892","4":{"version":1},"5":[{"2":"2","3":"3xWg-1659168452890","7":[{"8":"作用","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"2","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"：","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"MVCC ","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"rW9q-1659167266224","5":[{"2":"2","3":"0Fjp-1659167266221","7":[{"8":"undo的另一个作用是M/CC，即在InnoDB存储引擎中MVCC的实现是通过undo来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。"}]}]},{"3":"xWKJ-1659168520190","4":{"l":"h3"},"5":[{"2":"2","3":"7Eg1-1659168520189","7":[{"8":"undo","9":[{"0":"#34495e","2":"c"}]},{"8":"的存储结构 ","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"ldbU-1659167266406","4":{"l":"h4"},"5":[{"2":"2","3":"3CKH-1659167266405","7":[{"8":"回滚段与","9":[{"2":"b"},{"0":"#34495e","2":"c"}]},{"8":"undo","9":[{"0":"#34495e","2":"c"}]},{"8":"页","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"o2hn-1659167266516","5":[{"2":"2","3":"EAvH-1659167266515","7":[{"8":"InnoDB对undo log的管理采用段的方式，也就是 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"回滚段（","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"rollback segment","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"） ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"。每个回滚段记录了","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"1024 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"个 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"undo log segment ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"，而在每个undo log segment段中进行 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"undo","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"页 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"的申请。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"aj2D-1659168569897","4":{"li":"bkfX-1659168579669","lt":"unordered","ll":1},"5":[{"2":"2","3":"1koB-1659168569896","7":[{"8":"在 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"InnoDB1.1","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"版本之前 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"（不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务限制为 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"1024 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"。虽然对绝大多数的应用来说都已经够用。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"yBkS-1659168569902","4":{"li":"bkfX-1659168579669","lt":"unordered","ll":1},"5":[{"2":"2","3":"UmbE-1659168569901","7":[{"8":"从1.1版本开始InnoDB支持最大 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"128","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"个","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"rollback segment ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"，故其支持同时在线的事务限制提高到了 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"128*1024 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"hy1w-1659168698353","4":{"wrap":false,"la":"","th":"default"},"5":[{"3":"dUUA-1659168698351","5":[{"2":"2","3":"YF41-1659167266611","7":[{"8":"show variables like 'innodb_undo_logs'; "}]}],"6":"cl"}],"6":"cd"},{"3":"YrBS-1659167266708","5":[{"2":"2","3":"7hX6-1659167266707","7":[{"8":"虽然InnoDB1.1版本支持了128个rollback segment，但是这些rollback segment都存储于共享表空间ibdata中。从InnoDB1.2版本开始，可通过参数对rollback segment做进一步的设置。这些参数包括: "}]}]},{"3":"VSwg-1659167266794","4":{"li":"R3aE-1659168743127","lt":"unordered","ll":1},"5":[{"2":"2","3":"k6gr-1659167266792","7":[{"8":"innodb_undo_jirectory","9":[{"0":"#E96900FF","2":"c"}]},{"8":" :设置rollback segment文件所在的路径。这意味着rollback segment可以存放在共享表空间以外的位置，即可以设置为独立表空间。该参数的默认值为“.”，表示当前InnoDB存储引擎的目录。"}]}],"6":"l"},{"3":"KAvC-1659168736242","4":{"li":"R3aE-1659168743127","lt":"unordered","ll":1},"5":[{"2":"2","3":"2t5P-1659168736241","7":[{"8":"innodb_undo_logs ","9":[{"0":"#E96900FF","2":"c"}]},{"8":":设置rollback segment的个数，默认值为128。在InnoDB1.2版本中，该参数用来替换之前版本的参数innodb_rollback_segments。"}]}],"6":"l"},{"3":"og90-1659168736244","4":{"li":"R3aE-1659168743127","lt":"unordered","ll":1},"5":[{"2":"2","3":"c6Ec-1659168736243","7":[{"8":"innodb_undo_tablespaces","9":[{"0":"#E96900FF","2":"c"}]},{"8":":设置构成rollback segment文件的数量，这样rollback segment可以较为平均地分布在多个文件中。设置该参数后，会在路径innodb_undo_directory看到undo为前缀的文件，该文件就代表rollback segment文件。"}]}],"6":"l"},{"3":"UStX-1659168827950","5":[{"2":"2","3":"waja-1659168827947","7":[{"8":"undo页的重用","9":[{"0":"#A00E0EFF","2":"c"}]}]}]},{"3":"17eJ-1659168845512","5":[{"2":"2","3":"yw86-1659168845510","7":[{"8":"当我们开启一个事务需要写undo log的时候，就得先去undo log segment中去找到一个空闲的位置，当有空位的时候，就去申请undo页，在这个申请到的undo页中进行undo log的写入。我们知道mysql默认一页的大小是16k。"}]}]},{"3":"AgAT-1659168894691","4":{"version":1},"5":[{"2":"2","3":"b4W9-1659168894689","7":[{"8":"为每一个事务分配一个页，是非常浪费的（除非你的事务非常长)，假设你的应用的TPS(每秒处理的事务数目）为1000，那么1s就需要100o个页，大概需要16M的存储，1分钟大概需要1G的存储。如果照这样下去除非MySQL清理的非常勤快，否则随着时间的推移，磁盘空间会增长的非常快，而且很多空间都是浪费的。"}]}]},{"3":"XfV2-1659168880655","4":{"version":1},"5":[{"2":"2","3":"FfrU-1659168880654","7":[{"8":"于是undo页就被设计的可以重用了，当事务提交时，并不会立刻删除undo页。因为重用，所以这个undo页可能混杂着其他事务的undo log。undo log在commit后，会被放到一个链表中，然后判断undo页的使用空间是否小于3/4，如果小于3/4的话，则表示当前的undo页可以被重用，那么它就不会被回收，其他事务的undo log可以记录在当前undo页的后面。由于undo log是离散的，所以清理对应的磁盘空间时，效率不高。"}]}]},{"3":"77qr-1659168774528","4":{"l":"h4"},"5":[{"2":"2","3":"Z7jY-1659168774527","7":[{"8":"回滚段与事务 ","9":[{"2":"b"},{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"h"},{"3":"jWnZ-1659168938050","4":{"version":1},"5":[{"2":"2","3":"RDsu-1659168938051","7":[{"8":"1. 每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"fWvn-1659169541871","4":{"version":1},"5":[{"2":"2","3":"Wm07-1659169541870","7":[{"8":"2. 当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"KC6T-1659169541875","4":{"version":1},"5":[{"2":"2","3":"9ghS-1659169541874","7":[{"8":"3. 在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"ZWN3-1659169541881","4":{"version":1},"5":[{"2":"2","3":"WBlb-1659169541880","7":[{"8":"4. 回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"bCOt-1659169541886","4":{"version":1},"5":[{"2":"2","3":"zgIi-1659169541885","7":[{"8":"5. 当事务提交时，InnoDB存储引擎会做以下两件事情：","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"anO6-1659169541888","4":{"li":"ptPD-1659169571822","lt":"unordered","ll":1},"5":[{"2":"2","3":"uf8y-1659169541887","7":[{"8":"将undo log放入列表中，以供之后的purge操作","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"roKR-1659169541890","4":{"li":"ptPD-1659169571822","lt":"unordered","ll":1},"5":[{"2":"2","3":"ZJ7A-1659169541889","7":[{"8":"判断undo log所在的页是否可以重用，若可以分配给下个事务使用","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"okRB-1659168935579","4":{"l":"h4"},"5":[{"2":"2","3":"mB3L-1659168935576","7":[{"8":"回滚段中的数据分类 ","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"XW1Y-1659167267059","5":[{"2":"2","3":"NYk5-1659167267057","7":[{"8":"1. ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"未提交的回滚数据","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"(uncommitted undo information) ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"Baqn-1659169579309","4":{"version":1},"5":[{"2":"2","3":"njmJ-1659169579308","7":[{"8":"2. ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"已经提交但未过期的回滚数据","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"(committed undo information) ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"BTK5-1659169579311","4":{"version":1},"5":[{"2":"2","3":"8Gvx-1659169579310","7":[{"8":"3. ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"事务已经提交并过期的数据","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"(expired undo information) ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"NJrS-1659165689783","5":[{"2":"2","3":"dcjz-1659165689781","7":[{"8":"事务提交后并不能马上删除undo log及undo log所在的页。这是因为可能还有其他事务需要通过undo log来得到行记录之前的版本。故事务提交时将undo log放入一个链表中，是否可以最终删除undo log及undo log所在页由purge线程来判断。"}]}]},{"3":"3kQk-1659169644176","4":{"l":"h3"},"5":[{"2":"2","3":"KMsJ-1659169644175","7":[{"8":"undo","9":[{"0":"#34495e","2":"c"}]},{"8":"的类型 ","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"gRAJ-1659168762982","5":[{"2":"2","3":"P75M-1659168762979","7":[{"8":"在InnoDB存储引擎中，undo log分为：","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"IiHy-1659169671680","4":{"li":"9Fus-1659169678666","lt":"unordered","ll":1},"5":[{"2":"2","3":"kr6m-1659169671679","7":[{"8":"insert undo log ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"ZP9G-1659170037598","5":[{"2":"2","3":"mpUn-1659170037595","7":[{"8":"insert undo log是指在insert操作中产生的undo log。因为insert操作的记录，只对事务本身可见，对其他事务不可见(这是事务隔离性的要求)，故该undo log可以在事务提交后直接删除。不需要进行purge操作。"}]}]},{"3":"Bbu0-1659169671682","4":{"li":"9Fus-1659169678666","lt":"unordered","ll":1},"5":[{"2":"2","3":"IhbA-1659169671681","7":[{"8":"update undo log ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"Iygz-1659168763082","5":[{"2":"2","3":"YyIq-1659168763080","7":[{"8":"update undo log记录的是对delete和update操作产生的undo log。该undo log可能需要提供MVCc机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待qurge线程进行最后的删除。"}]}]},{"3":"9kv0-1659170076513","4":{"l":"h3"},"5":[{"2":"2","3":"GTfm-1659170076512","7":[{"8":"undo log","9":[{"0":"#34495e","2":"c"}]},{"8":"的生命周期 ","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"i0Sv-1659170141662","4":{"l":"h4"},"5":[{"2":"2","3":"pfZM-1659170141663","7":[{"8":"简要生成过程"}]}],"6":"h"},{"3":"lo0l-1659170116131","4":{"version":1,"u":"https://note.youdao.com/yws/res/a/WEBRESOURCE256dce31e5c68f11bf8b825e0ea4c2ba","w":582,"h":248},"6":"im"},{"3":"eJD6-1659170124818","4":{"version":1,"u":"https://note.youdao.com/yws/res/f/WEBRESOURCEd51449dbe995dae721c5f09e4913111f","w":582,"h":337},"6":"im"},{"3":"lWlC-1659168763513","4":{"l":"h4"},"5":[{"2":"2","3":"SewD-1659168763510","7":[{"8":"详细生成过程","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"Td2f-1659170193844","4":{"version":1,"u":"https://note.youdao.com/yws/res/6/WEBRESOURCE2023c88c651c7db5989de60eb7290776","w":412,"h":165},"6":"im"},{"3":"NSKF-1659168763820","4":{"l":"h4"},"5":[{"2":"2","3":"Z2UP-1659168763818","7":[{"8":"undo log","9":[{"0":"#34495e","2":"c"}]},{"8":"是如何回滚的","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"fCiR-1659168763916","5":[{"2":"2","3":"4urh-1659168763913","7":[{"8":"以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"9bHd-1659170250383","4":{"version":1},"5":[{"2":"2","3":"L99T-1659170250382","7":[{"8":"1. 通过undo no=3的日志把id=2的数据删除","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"xMVq-1659170250386","4":{"version":1},"5":[{"2":"2","3":"z3y6-1659170250385","7":[{"8":"2. 通过undo no=2的日志把id=1的数据的deletemark还原成0 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"9J9u-1659170250389","4":{"version":1},"5":[{"2":"2","3":"qZWA-1659170250388","7":[{"8":"3. 通过undo no=1的日志把id=1的数据的name还原成Tom ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"a2zg-1659170250392","4":{"version":1},"5":[{"2":"2","3":"b2LR-1659170250391","7":[{"8":"4. 通过undo no=0的日志把id=1的数据删除","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"uB13-1659170196686","4":{"l":"h4"},"5":[{"2":"2","3":"Sp8o-1659170196682","7":[{"8":"undo log","9":[{"0":"#34495e","2":"c"}]},{"8":"的删除","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"JbZ1-1659170196874","4":{"li":"v619-1659170500937","lt":"unordered","ll":1},"5":[{"2":"2","3":"bh87-1659170196872","7":[{"8":"针对于insert undo log","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"z0FM-1659170492334","4":{"version":1},"5":[{"2":"2","3":"5FQG-1659170492333","7":[{"8":"因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"1YOO-1659170492338","4":{"li":"7st4-1659170502156","lt":"unordered","ll":1},"5":[{"2":"2","3":"H5Mz-1659170492337","7":[{"8":"针对于update undo log ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"Qx8X-1659170492340","4":{"version":1},"5":[{"2":"2","3":"efCs-1659170492339","7":[{"8":"该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"Xf4f-1659168764005","5":[{"2":"2","3":"v59F-1659168764003","7":[{"8":"补充:"}]}]},{"3":"Cykw-1659170524988","4":{"version":1},"5":[{"2":"2","3":"zu3L-1659170524987","7":[{"8":"purge线程两个主要作用是:清理undo页和清除page里面带有Delete_Bit标识的数据行。在InnoDB中，事务中的Delete操作实际上并不是真正的删除掉数据行，而是一种Delete Mark操作，在记录上标识Delete_Bit，而不删除记录。是一种\"假删除\".只是做了个标记，真正的删除工作需要后台purge线程去完成。"}]}]},{"3":"708J-1659168764090","5":[{"2":"2","3":"WdPV-1659168764088","7":[{"8":"","9":[{"0":"#000000","2":"c"}]}]}]}],"title":"","__compress__":true}