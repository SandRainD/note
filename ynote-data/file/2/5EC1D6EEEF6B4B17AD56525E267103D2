<?xml version="1.0" encoding="UTF-8" standalone="no"?><note xmlns="http://note.youdao.com" file-version="0" schema-version="1.0.3"><head/><body><para><coId>8954-1637065710589</coId><text/><inline-styles/><styles/></para><table><coId>8883-1637065710589</coId><resource-list/><content>{"cells":[{"value":"# 问题： docker是如何处理容器网络访问的？\n \n# [root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker run -d -P --name tomcat01 tomcat\n \n# 查看容器内部的网络地址 ip addr\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat01 ip addr， 发现容器启动的时候得到一个eth0@if115 ip地址，docker分配的！\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n114: eth0@if115: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default \n    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0\n    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0\n       valid_lft forever preferred_lft forever\n \n# 思考： linux 能不能ping通容器？\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# ping 172.17.0.2\nPING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.\n64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.077 ms\n64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.069 ms\n64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.075 ms\n \n# linux 可以 ping 通docker容器内部！"}],"heights":[40],"widths":[620]}</content><styles/></table><para><coId>7649-1637065710589</coId><text>我们每启动一个docker容器， docker就会给docker容器分配一个ip， 我们只要安装了docker，就会有一个网卡 docker0桥接模式，使用的技术是veth-pair技术！</text><inline-styles><font-size><from>0</from><to>94</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>1070-1637066069867</coId><text># 我们发现这个容器带来网卡，都是一对对的</text><inline-styles><font-size><from>0</from><to>21</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>7540-1637066071751</coId><text># veth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一端连着协议，一端彼此相连</text><inline-styles><font-size><from>0</from><to>47</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>1827-1637066071751</coId><text># 正因为有这个特性，veth-pair充当一个桥梁， 连接各种虚拟网络设备</text><inline-styles><font-size><from>0</from><to>38</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>6058-1637066071752</coId><text># OpenStac， Docker容器之间的链接，OVS的链接， 都是使用veth-pair技术</text><inline-styles><font-size><from>0</from><to>49</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>1494-1637066071752</coId><text/><inline-styles/><styles/></para><para><coId>4578-1637066070008</coId><text>容器与容器之间是可以相互ping通的！</text><inline-styles><font-size><from>0</from><to>19</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>6644-1637066070102</coId><text>结论：tomcat01和tomcat02是共用的一个路由器，docker0</text><inline-styles><font-size><from>0</from><to>37</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>1280-1637066070250</coId><text>所有容器不指定网络的情况下，都是docker0路由的，doucker会给我们的容器分配一个默认的可用IP</text><inline-styles><font-size><from>0</from><to>52</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>2023-1637066722400</coId><text/><inline-styles/><styles/></para><para><coId>9217-1637066070347</coId><text>Docker使用的是Linux的桥接，宿主机中是一个Docker容器的网桥docker0.</text><inline-styles><font-size><from>0</from><to>45</to><value>16</value></font-size><color><from>0</from><to>45</to><value>#4d4d4d</value></color><back-color><from>0</from><to>45</to><value>#ffffff</value></back-color></inline-styles><styles/></para><para><coId>6760-1637066070453</coId><text>Docker中的所有的网络接口都是虚拟的，虚拟的转发效率高！（内网传递文件！）</text><inline-styles><font-size><from>0</from><to>39</to><value>16</value></font-size><color><from>0</from><to>39</to><value>#4d4d4d</value></color><back-color><from>0</from><to>39</to><value>#ffffff</value></back-color></inline-styles><styles><line-height>1.625</line-height></styles></para><para><coId>4175-1637066729950</coId><text>只要容器删除，对应的网桥一对就没有了！</text><inline-styles><font-size><from>0</from><to>19</to><value>16</value></font-size><color><from>0</from><to>19</to><value>#4d4d4d</value></color><back-color><from>0</from><to>19</to><value>#ffffff</value></back-color></inline-styles><styles><line-height>1.625</line-height></styles></para><para><coId>4523-1637066070582</coId><text/><inline-styles/><styles/></para><heading compat="true" level="a"><coId>1190-1637067545184</coId><text>容器互联</text><inline-styles><bold><from>0</from><to>4</to><value>true</value></bold><font-size><from>0</from><to>4</to><value>32</value></font-size></inline-styles><styles/></heading><heading compat="true" level="1"><coId>4850-1637068326231</coId><text>通过--link</text><inline-styles><bold><from>0</from><to>8</to><value>true</value></bold><font-size><from>0</from><to>8</to><value>28</value></font-size></inline-styles><styles/></heading><para><coId>6690-1637067545467</coId><text>思考一个场景，我们编写了一个微服务，database url =ip； 项目不重启，数据ip换掉了，我们希望可以处理这个问题，可以按名字来进行访问容器</text><inline-styles><font-size><from>0</from><to>75</to><value>16</value></font-size></inline-styles><styles/></para><table><coId>5644-1637067577206</coId><resource-list/><content>{"cells":[{"value":"[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat02 ping tomcat01\nping: tomcat01: Name or service not known\n \n# 如何可以解决呢？\n# 通过--link既可以解决网络连通问题\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker run -d -P  --name tomcat03 --link tomcat02 tomcat\n3a2bcaba804c5980d94d168457c436fbd139820be2ee77246888f1744e6bb473\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES\n3a2bcaba804c        tomcat              \"catalina.sh run\"   4 seconds ago       Up 3 seconds        0.0.0.0:32772-&gt;8080/tcp   tomcat03\nf22ed47ed1be        tomcat              \"catalina.sh run\"   57 minutes ago      Up 57 minutes       0.0.0.0:32771-&gt;8080/tcp   tomcat02\n9d97f93401a0        tomcat              \"catalina.sh run\"   About an hour ago   Up About an hour    0.0.0.0:32770-&gt;8080/tcp   tomcat01\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat03 ping tomcat02\nPING tomcat02 (172.17.0.3) 56(84) bytes of data.\n64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.129 ms\n64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.100 ms\n64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.110 ms\n64 bytes from tomcat02 (172.17.0.3): icmp_seq=4 ttl=64 time=0.107 ms\n \n# 反向可以ping通吗？\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat02 ping tomcat03\nping: tomcat03: Name or service not known\n "}],"heights":[40],"widths":[620]}</content><styles/></table><para><coId>4089-1637067569275</coId><text>docker network ls  // 显示docker网络链接列表</text><inline-styles><font-size><from>0</from><to>36</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>1484-1637067772582</coId><text>docker network inspect 容器id   //查看docker容器网络具体信息</text><inline-styles><font-size><from>0</from><to>48</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>3199-1637067762027</coId><text>docker network rm 网络名称   //删除网络</text><inline-styles><font-size><from>0</from><to>31</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>3031-1637067545666</coId><text/><inline-styles/><styles/></para><para><coId>2980-1637067583819</coId><text>探究：inspect！</text><inline-styles><font-size><from>0</from><to>11</to><value>16</value></font-size><color><from>0</from><to>11</to><value>#4d4d4d</value></color><back-color><from>0</from><to>11</to><value>#ffffff</value></back-color></inline-styles><styles/></para><image><coId>7914-1637068217235</coId><source>https://note.youdao.com/yws/res/15117/22184B69BCD04D7E9505CF8A9FB7F141</source><text/><styles><width>620</width><height>300</height></styles></image><para><coId>8221-1637068228240</coId><text/><inline-styles/><styles/></para><table><coId>6291-1637068228240</coId><resource-list/><content>{"cells":[{"value":"[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat03 cat /etc/hosts\n127.0.0.1   localhost\n::1 localhost ip6-localhost ip6-loopback\nfe00::0 ip6-localnet\nff00::0 ip6-mcastprefix\nff02::1 ip6-allnodes\nff02::2 ip6-allrouters\n172.17.0.3  tomcat02 f22ed47ed1be\n172.17.0.4  3a2bcaba804c"}],"heights":[40],"widths":[620]}</content><styles/></table><para><coId>1020-1637067584279</coId><text>本质探究：--link 就是我们在hosts配置中增加了一个172.17.0.3 tomcat02 f22ed47ed1be</text><inline-styles><font-size><from>0</from><to>62</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>2981-1637068242470</coId><text>我们现在玩Docker已经不建议使用--link了！</text><inline-styles><font-size><from>0</from><to>26</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>7513-1637068242470</coId><text>自定义网络！不使用Docker0！</text><inline-styles><font-size><from>0</from><to>17</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>3124-1637068242470</coId><text>Docker0的问题：它不支持容器名链接访问！</text><inline-styles><font-size><from>0</from><to>23</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>4437-1637068232633</coId><text/><inline-styles/><styles/></para><para><coId>8900-1637068232775</coId><text/><inline-styles/><styles/></para><heading compat="true" level="1"><coId>6622-1637068232879</coId><text>自定义网络</text><inline-styles><bold><from>0</from><to>5</to><value>true</value></bold><font-size><from>0</from><to>5</to><value>28</value></font-size></inline-styles><styles/></heading><para><coId>7098-1637068260257</coId><text>查看所有的docker网络docker network ls</text><inline-styles><font-size><from>0</from><to>30</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>5540-1637068260912</coId><text>网络模式</text><inline-styles><font-size><from>0</from><to>4</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>5876-1637068396529</coId><text>bridge： 桥接模式，桥接 docker 默认，自己创建的也是用brdge模式</text><inline-styles><font-size><from>0</from><to>41</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>8746-1637068396529</coId><text>none： 不配置网络</text><inline-styles><font-size><from>0</from><to>11</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>9258-1637068396529</coId><text>host： 和宿主机共享网络</text><inline-styles><font-size><from>0</from><to>14</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>1388-1637068396529</coId><text>container：容器网络连通！（用的少， 局限很大）</text><inline-styles><font-size><from>0</from><to>28</to><value>16</value></font-size></inline-styles><styles/></para><table><coId>6212-1637068541049</coId><resource-list/><content>{"cells":[{"value":"# 我们直接启动的命令默认有一个 --net bridge，而这个就是我们的docker0\ndocker run -d -P --name tomcat01 tomcat\ndocker run -d -P --name tomcat01 --net bridge tomcat\n \n# docker0特点，默认，容器名不能访问， --link可以打通连接！\n# 我们可以自定义一个网络！\n# --driver bridge\n# --subnet 192.168.0.0/16 可以支持255*255个网络 192.168.0.2 ~ 192.168.255.254\n# --gateway 192.168.0.1\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet\n26a5afdf4805d7ee0a660b82244929a4226470d99a179355558dca35a2b983ec\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\n30d601788862        bridge              bridge              local\n226019b14d91        host                host                local\n26a5afdf4805        mynet               bridge              local\n7496c014f74b        none                null                local"}],"heights":[40],"widths":[620]}</content><styles/></table><para><coId>4086-1637068233097</coId><text> 在自己创建的网络里面启动两个容器</text><inline-styles><font-size><from>0</from><to>17</to><value>16</value></font-size></inline-styles><styles/></para><table><coId>2686-1637068899178</coId><resource-list/><content>{"cells":[{"value":"[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker run -d -P --name tomcat-net-01 --net mynet tomcat\n0e85ebe6279fd23379d39b27b5f47c1e18f23ba7838637802973bf6449e22f5c\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker run -d -P --name tomcat-net-02 --net mynet tomcat\nc6e462809ccdcebb51a4078b1ac8fdec33f1112e9e416406b606d0c9fb6f21b5\n2. \n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker network inspect mynet\n........\n\n# 再次拼连接\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat-net-01 ping 192.168.0.3\nPING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.\n64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.113 ms\n64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.093 ms\n^C\n--- 192.168.0.3 ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 999ms\nrtt min/avg/max/mdev = 0.093/0.103/0.113/0.010 ms\n# 现在不使用 --link也可以ping名字了！\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat-net-01 ping tomcat-net-02\nPING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.\n64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.068 ms","inlineStyles":{"italic":[{"from":348,"to":378,"value":true},{"from":379,"to":387,"value":true}],"color":[{"from":316,"to":348,"value":"#383a42"},{"from":348,"to":378,"value":"#a0a1a7"},{"from":379,"to":387,"value":"#a0a1a7"}]}}],"heights":[40],"widths":[620]}</content><styles/></table><para><coId>3177-1637068883315</coId><text>我们自定义的网络docker都已经帮我们维护好了对应的关系，推荐我们平时这样使用网络</text><inline-styles><font-size><from>0</from><to>42</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>1519-1637069000262</coId><text>好处：</text><inline-styles><font-size><from>0</from><to>3</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>4226-1637069000262</coId><text>redis - 不同的集群使用不同的网络，保证集群时安全和健康的</text><inline-styles><font-size><from>0</from><to>32</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>3085-1637069000263</coId><text>mysql - 不同的集群使用不同的网络，保证集群时安全和健康的</text><inline-styles><font-size><from>0</from><to>32</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>9351-1637068883500</coId><text/><inline-styles/><styles/></para><heading compat="true" level="1"><coId>5822-1637068545864</coId><text>网络连通</text><inline-styles><bold><from>0</from><to>4</to><value>true</value></bold><font-size><from>0</from><to>4</to><value>28</value></font-size></inline-styles><styles/></heading><table><coId>4627-1637223320379</coId><resource-list/><content>{"cells":[{"value":"[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker network connect  mynet tomcat01\n \n# 连通之后就是讲tomcat01 放到了mynet网路下\n# 一个容器两个ip地址：\n# 阿里云服务器，公网ip，私网ip"}],"heights":[40],"widths":[620]}</content><styles/></table><para><coId>1852-1637069063348</coId><text>网络连通实战</text><inline-styles><font-size><from>0</from><to>6</to><value>16</value></font-size></inline-styles><styles/></para><table><coId>3459-1637223667245</coId><resource-list/><content>{"cells":[{"value":"\n# 创建网卡\ndocker network create redis --subnet 172.38.0.0/16\n \n# 通过脚本创建六个redis配置\nfor port in $(seq 1 6); \\\ndo \\\nmkdir -p /mydata/redis/node-${port}/conf\ntouch /mydata/redis/node-${port}/conf/redis.conf\ncat &lt;&lt; EOF &gt;/mydata/redis/node-${port}/conf/redis.conf\nport 6379\nbind 0.0.0.0\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 5000\ncluster-announce-ip 172.38.0.1${port}\ncluster-announce-port 6379\ncluster-announce-bus-port 16379\nappendonly yes\nEOF\ndone\n# 创建结点1\ndocker run -p 6371:6379 -p 16371:16379 --name redis-1 \\\n-v /mydata/redis/node-1/data:/data \\\n-v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n \n#创建结点2\ndocker run -p 6372:6379 -p 16372:16379 --name redis-2 \\\n-v /mydata/redis/node-2/data:/data \\\n-v /mydata/redis/node-2/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.12 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n#创建结点3\ndocker run -p 6373:6379 -p 16373:16379 --name redis-3 \\\n-v /mydata/redis/node-3/data:/data \\\n-v /mydata/redis/node-3/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.13 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n#创建结点4\ndocker run -p 6374:6379 -p 16374:16379 --name redis-4 \\\n-v /mydata/redis/node-4/data:/data \\\n-v /mydata/redis/node-4/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.14 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n#创建结点5\ndocker run -p 6375:6379 -p 16375:16379 --name redis-5 \\\n-v /mydata/redis/node-5/data:/data \\\n-v /mydata/redis/node-5/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.15 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n#创建结点6\ndocker run -p 6376:6379 -p 16376:16379 --name redis-6 \\\n-v /mydata/redis/node-6/data:/data \\\n-v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n \n# 创建集群\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it redis-1 /bin/sh\n/data # ls\nappendonly.aof  nodes.conf\n/data # redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1\n&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...\nMaster[0] -&gt; Slots 0 - 5460\nMaster[1] -&gt; Slots 5461 - 10922\nMaster[2] -&gt; Slots 10923 - 16383\nAdding replica 172.38.0.15:6379 to 172.38.0.11:6379\nAdding replica 172.38.0.16:6379 to 172.38.0.12:6379\nAdding replica 172.38.0.14:6379 to 172.38.0.13:6379\nM: 541b7d237b641ac2ffc94d17c6ab96b18b26a638 172.38.0.11:6379\n   slots:[0-5460] (5461 slots) master\nM: a89c1f1245b264e4a402a3cf99766bcb6138dbca 172.38.0.12:6379\n   slots:[5461-10922] (5462 slots) master\nM: 259e804d6df74e67a72e4206d7db691a300c775e 172.38.0.13:6379\n   slots:[10923-16383] (5461 slots) master\nS: 9b19170eea3ea1b92c58ad18c0b5522633a9e271 172.38.0.14:6379\n   replicates 259e804d6df74e67a72e4206d7db691a300c775e\nS: 061a9d38f22910aaf0ba1dbd21bf1d8f57bcb7d5 172.38.0.15:6379\n   replicates 541b7d237b641ac2ffc94d17c6ab96b18b26a638\nS: 7a16b9bbb0615ec95fc978fa62fc054df60536f0 172.38.0.16:6379\n   replicates a89c1f1245b264e4a402a3cf99766bcb6138dbca\nCan I set the above configuration? (type 'yes' to accept): yes\n&gt;&gt;&gt; Nodes configuration updated\n&gt;&gt;&gt; Assign a different config epoch to each node\n&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster\nWaiting for the cluster to join\n...\n&gt;&gt;&gt; Performing Cluster Check (using node 172.38.0.11:6379)\nM: 541b7d237b641ac2ffc94d17c6ab96b18b26a638 172.38.0.11:6379\n   slots:[0-5460] (5461 slots) master\n   1 additional replica(s)\nM: a89c1f1245b264e4a402a3cf99766bcb6138dbca 172.38.0.12:6379\n   slots:[5461-10922] (5462 slots) master\n   1 additional replica(s)\nS: 7a16b9bbb0615ec95fc978fa62fc054df60536f0 172.38.0.16:6379\n   slots: (0 slots) slave\n   replicates a89c1f1245b264e4a402a3cf99766bcb6138dbca\nS: 061a9d38f22910aaf0ba1dbd21bf1d8f57bcb7d5 172.38.0.15:6379\n   slots: (0 slots) slave\n   replicates 541b7d237b641ac2ffc94d17c6ab96b18b26a638\nM: 259e804d6df74e67a72e4206d7db691a300c775e 172.38.0.13:6379\n   slots:[10923-16383] (5461 slots) master\n   1 additional replica(s)\nS: 9b19170eea3ea1b92c58ad18c0b5522633a9e271 172.38.0.14:6379\n   slots: (0 slots) slave\n   replicates 259e804d6df74e67a72e4206d7db691a300c775e\n[OK] All nodes agree about slots configuration.\n&gt;&gt;&gt; Check for open slots...\n&gt;&gt;&gt; Check slots coverage...\n[OK] All 16384 slots covered.\n "}],"heights":[40],"widths":[620]}</content><styles/></table><para><coId>1534-1637069063644</coId><text/><inline-styles/><styles/></para><para><coId>8435-1637069063814</coId><text/><inline-styles/><styles/></para><para><coId>6555-1637068233188</coId><text/><inline-styles/><styles/></para><para><coId>1063-1637068233384</coId><text/><inline-styles/><styles/></para><para><coId>4638-1637068233500</coId><text/><inline-styles/><styles/></para><para><coId>3575-1637068233604</coId><text/><inline-styles/><styles/></para></body></note>