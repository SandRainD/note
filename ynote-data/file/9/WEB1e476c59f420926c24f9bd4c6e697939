{"2":"1","3":"Ju9C-1621846617594","4":{"version":1,"incompatibleVersion":0,"headerStyle":{"t":"center"},"footerStyle":{"t":"center"},"fv":"0","hd":[{"8":"","p":1}],"ft":[{"8":"","p":1}]},"5":[{"3":"3060-1621846615933","5":[{"2":"2","3":"p5PQ-1621846617594","7":[{"8":"面向对象两大要素：","9":[{"0":18,"2":"fs"}]}]}]},{"3":"WWxc-1644990378085","5":[{"2":"2","3":"HwHi-1644990378083","7":[{"8":"类：对一类事务描述，是一类抽象的、概念上的定义","9":[{"0":18,"2":"fs"}]}]}]},{"3":"7Pgx-1644990425262","5":[{"2":"2","3":"qqLi-1644990425249","7":[{"8":"对象：是实际存在的该类事物的的每个个体，因而也称为实例（instance）","9":[{"0":18,"2":"fs"}]}]}]},{"3":"8grg-1644992162301","5":[{"2":"2","3":"pBrh-1644992162298","7":[{"8":"类的成员：属性，方法，构造器","9":[{"0":18,"2":"fs"}]}]}]},{"3":"ZsD3-1644992164275","5":[{"2":"2","3":"XW7t-1644992164275","7":[{"8":"如果创建一个类的多个对象，则每个对象都独立的拥有一套类的属性；意味着我们修改一个对象的属性a，不会影响另一个对象的a的属性值。","9":[{"0":18,"2":"fs"}]}]}]},{"3":"ftQd-1644992256695","5":[{"2":"2","3":"ejJc-1644992256694","7":[{"8":"","9":[{"0":18,"2":"fs"}]}]}]},{"3":"DHIi-1644992822219","5":[{"2":"2","3":"hu3N-1644992822216","7":[{"8":"成员变量和局部变量","9":[{"0":18,"2":"fs"}]}]}]},{"3":"7P4A-1644992832473","5":[{"2":"2","3":"sQsi-1644992832472","7":[{"8":"成员变量：直接声明在类的一堆{}内；局部变量：声明在方法内，方法形参，代码块内，构造器形参，构造器内部的变量。成员变量（属性）可以使用权限修饰符指明权限(private....)。属性都有默认初始化值，局部变量需要先显性赋值。属性加载到堆空间中，局部变量加载到栈空间中。","9":[{"0":18,"2":"fs"}]}]}]},{"3":"B0to-1645064110646","5":[{"2":"2","3":"g1Nv-1645064110643","7":[{"8":"根据问题需要，选择问题所针对的现实世界中的实体。从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。将类实例化成计算机世界中的对象。对象是计算机世界中解决问题的最终工具。","9":[{"0":18,"2":"fs"}]}]}]},{"3":"g6kz-1645066060112","5":[{"2":"2","3":"Sgkk-1645066060111","7":[{"8":"main方法：可以添加参数:javac demo (args)","9":[{"0":18,"2":"fs"}]}]}]},{"3":"C6Ru-1647398160135","5":[{"2":"2","3":"jocN-1647398160134","7":[{"8":"代码块：一般用来初始化类，对象。只能用static修饰，静态代码块随着类的加载而执行只执行一次（不可以调用非静态属性或方法，非静态代码块每创造一次对象就执行一次。各种初始化结构顺序：由父即子，静态先行","9":[{"0":18,"2":"fs"}]}]}]},{"3":"Kvni-1647400422897","4":{"version":1,"u":"https://note.youdao.com/yws/res/17373/WEBRESOURCEe7c81da8ccf35f3c181ee44dd026c586","w":120,"h":67,"s":{"fo":"left"}},"6":"im"},{"3":"Uvz2-1647398160244","5":[{"2":"2","3":"4MOR-1647398160243","7":[{"8":"结果：3","9":[{"0":18,"2":"fs"}]}]}]},{"3":"3jnA-1647398160362","5":[{"2":"2","3":"4mS1-1647398160362","7":[{"8":"","9":[{"0":18,"2":"fs"}]}]}]},{"3":"pA6o-1647400480123","5":[{"2":"2","3":"lqqZ-1647400480123","7":[{"8":"","9":[{"0":18,"2":"fs"}]}]}]},{"3":"87sS-1645064120521","5":[{"2":"2","3":"kIiv-1645064120521","7":[{"8":"理解万事万物皆对象：","9":[{"0":18,"2":"fs"}]}]}]},{"3":"1D7D-1645064793480","5":[{"2":"2","3":"M4dp-1645064793479","7":[{"8":"在java语言中，我们将功能结构封装到类中，通过类的实例化，来调用具体的功能结构","9":[{"0":18,"2":"fs"}]}]}]},{"3":"yZlT-1647400484688","5":[{"2":"2","3":"7JkB-1647400484687","7":[{"8":"","9":[{"0":18,"2":"fs"}]}]}]},{"3":"VoOU-1645066000941","5":[{"2":"2","3":"V5PV-1645066000939","7":[{"8":"方法的重载：","9":[{"0":18,"2":"fs"}]}]}]},{"3":"dcdg-1645066096889","5":[{"2":"2","3":"CY4Z-1645066096888","7":[{"8":"在同一个类中，允许存在一个以上同名的方法，只要参数个数和参数类型不同即可。","9":[{"0":18,"2":"fs"}]}]}]},{"3":"Pa6r-1645064120683","5":[{"2":"2","3":"BbCM-1645064120683","7":[{"8":"特殊的：可变形参。public void show(String ... strs){}可以匹配0~n个的参数，和String[] strs 类似，而且两者不能重载。可变形参须放在参数的最后","9":[{"0":18,"2":"fs"}]}]}]},{"3":"g3eL-1645082637939","4":{"version":1,"u":"https://note.youdao.com/yws/res/17064/WEBRESOURCEfb8d89b66e1de16b33fa7882aef066c6","w":398,"h":271},"6":"im"},{"3":"29hw-1645064120827","5":[{"2":"2","3":"Atj6-1645064120826","7":[{"8":"string类型本质是char类型的数组，改变字符串其实就是新创建了一个字符串对象。（即无法对原来的char数组进行修改，数组长度一旦确定，就无法更改","9":[{"0":18,"2":"fs"}]}]}]},{"3":"ZhZa-1645087964523","5":[{"2":"2","3":"GBc8-1645087964523","7":[{"8":"构造器用来对象的初始化，对象的创建是用new关键字创造的，构造器的权限与类的权限相同","9":[{"0":18,"2":"fs"}]}]}]},{"3":"pP6C-1645093177985","5":[{"2":"2","3":"DxYh-1645093177984","7":[{"8":"this","9":[{"0":18,"2":"fs"},{"0":"#F33232","2":"c"}]},{"8":"：调用该方法/属性的对象","9":[{"0":18,"2":"fs"}]}]}]},{"3":"XMG5-1646296359099","4":{"version":1,"sr":"https://note.youdao.com/yws/res/17113/1646296355","re":"https://note.youdao.com/yws/res/17111/WEBRESOURCE12d283a5da72d3c0eadfa1cda18c830e","fn":"拓展：类与类之间的关系说明.pdf","fl":473846},"6":"a"},{"3":"TUVX-1646296359089","5":[{"2":"2","3":"8kiW-1646296359089","7":[{"8":"方法的重写：在子类中可以根据需要对从父类中继承来的方法进行改造，子类的方法将覆盖父类的方法，子类重写的方法的权限不小于父类方法"}]}]},{"3":"iUML-1646299549415","5":[{"2":"2","3":"IRhS-1646299549413","7":[{"8":"super","9":[{"0":"#F33232","2":"c"}]},{"8":"：我们可以再类的方法或构造器中使用super关键字显式调用父类的属性或方法"}]}]},{"3":"w7cT-1646299982376","5":[{"2":"2","3":"AKXu-1646299982370","7":[{"8":"在构造器的首行，没有显式声明this或super，则默认调用父类的构造器"}]}]},{"3":"qAYS-1646299982498","5":[{"2":"2","3":"4mUN-1646299982497","7":[{"8":"子类对象实例化的过程：堆空间中，会加载所有父类的属性，通过子类的的构造器创建对象时，我们会间接当调用父类的构造器，一直调用到java.lang.Object类中的构造器为止。"}]}]},{"3":"3Pii-1645087965110","5":[{"2":"2","3":"IwOE-1645087965109","7":[{"8":"instanceof","9":[{"0":"#F33232","2":"c"}]},{"8":"：判断对象是否是类的实例"}]}]},{"3":"bCcO-1646978688885","5":[{"2":"2","3":"5YkY-1646978688877","7":[{"8":"对于引用数据类型来说，比较的是两个引用数据类型变量地址值是否相同","9":[{"0":18,"2":"fs"}]}]}]},{"3":"w8yD-1646978687089","5":[{"2":"2","3":"iwpQ-1646978687086","7":[{"8":"static","9":[{"0":18,"2":"fs"},{"0":"#F33232","2":"c"}]},{"8":"：用来修饰属性方法代码块内部类，static修饰的属性成为静态变量，静态变量随着类的加载而加载，可以通过 类.静态变量  的方式进行调用，只会加载一次，只在内存中存在一份，存在方法区的静态域中。","9":[{"0":18,"2":"fs"},{"0":"#000000","2":"c"}]},{"8":"不能将正常方法体内部的局部变量声明为static的","9":[{"0":18,"2":"fs"}]}]}]},{"3":"kmyl-1647313303619","5":[{"2":"2","3":"YV6e-1647313303618","7":[{"8":"在静态的方法中，不可以使用this,super关键字。","9":[{"0":18,"2":"fs"},{"0":"#000000","2":"c"},{"0":"#FFF2CC","2":"bg"}]}]}]},{"3":"YkCd-1648275422316","5":[{"2":"2","3":"d7ww-1648275422315","7":[{"8":"实例变量：创建类的多个对象，每个对象都拥有一套完整的类中的非静态属性，当修改其中一个对象的非静态属性时，不会导致其他对象中同样属性值的修改","9":[{"0":18,"2":"fs"}]}]}]},{"3":"Enaq-1647244652596","4":{"version":1},"5":[{"2":"2","3":"yw5E-1647244652595","7":[{"8":"静态变量（类变量）：多个对象共享同一个静态变量，当通过某一个对象修改静态变量，其他变量调用时也是被修改过的","9":[{"0":18,"2":"fs"}]}]}]},{"3":"qjBM-1647244652725","4":{"version":1},"5":[{"2":"2","3":"HcIg-1647244652725","7":[{"8":"静态方法：可以通过类.静态方法 的方式调用，静态方法中只能调用静态的方法或属性，费静态方法中，既可以调用非静态也可调用静态","9":[{"0":18,"2":"fs"}]}]}]},{"3":"sv4Y-1647313300048","5":[{"2":"2","3":"FTRx-1647313300047","7":[{"8":"final","9":[{"0":18,"2":"fs"},{"0":"#F33232","2":"c"}]},{"8":"：修饰","9":[{"0":18,"2":"fs"},{"0":"#000000","2":"c"}]},{"8":"[[ 类、方法、变量。类：该类不能"},{"8":"被继承。方法：此方法不可以被重写。final修饰的属性，可以显式初始化、代码块中初始化、构造器中初始化。final修饰的局部变量是常量，final可以修饰形参","9":[{"0":18,"2":"fs"},{"0":"#000000","2":"c"}]}]}]},{"3":"wesG-1647400491602","5":[{"2":"2","3":"vx1B-1647400491602","7":[{"8":"abstract：","9":[{"0":18,"2":"fs"},{"0":"#F33232","2":"c"}]},{"8":"抽象的，可以用来修饰类&方法。不能修饰属性构造器，私有方法，静态方法，final方法，final类。+++++修饰类：该类不能实例化，抽象类中一定有构造器，便于子类实例化时调用。+++++修饰方法：没有方法体，包含抽象方法的类，一定是一个抽象类，抽象类中可以没有抽象方法。若子类重写了父类中所有的抽象方法后，改子类方可实例化；若子类没有重写父类中所有的抽象方法，则此类也是一个抽象类，需要abstract修饰。","9":[{"0":18,"2":"fs"},{"0":"#000000","2":"c"}]},{"8":"随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。","9":[{"0":18,"2":"fs"},{"2":"i"}]}]}]},{"3":"xDx8-1648273221313","5":[{"2":"2","3":"NV9M-1648273221310","7":[{"8":"interface接口：","9":[{"0":18,"2":"fs"},{"0":"#F33232","2":"c"}]},{"8":"java不支持多重继承，使用接口可以使类实现类似多继承的效果。接口和类是两个并列的结构，接口中可以定义全局常量(public static final可以省略不写)，抽象方法(public abstract)，静态方法，默认方法；接口中不能定义构造器。实现类需要重写接口中所有的抽象方法，java类可以实现多个接口，弥补了java单继承的局限性。接口与接口之间可以多继承。接口的使用体现了多态性。接口中定义的静态方法，只能通过接口调用；通过实现类的对象，可以调用接口中的默认方法，如果实现类重写了接口中的默认方法，调用的是重写后的方法。","9":[{"0":18,"2":"fs"},{"0":"#000000","2":"c"}]},{"8":"如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。-->类优先原则。知识点4:如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法,那么在实现类没有重写此方法的情况下，报错。-->接口冲突，这就需要我们必须在实现类中重写此方法。","9":[{"0":18,"2":"fs"}]}]}]},{"3":"Yqok-1650171820517","5":[{"2":"2","3":"v1ux-1650171820513","7":[{"8":"如何在子类(或实现类)的方法中调用父类、接口中被重写的方法："}]}]},{"3":"wpG9-1650171840754","5":[{"2":"2","3":"0edA-1650171840752","7":[{"8":"接口名称.super.method();"}]}]},{"3":"tIt1-1648278766280","4":{"version":1,"u":"https://note.youdao.com/yws/res/17436/WEBRESOURCE77a658d92857269c7f4572f07d30134f","w":389,"h":180},"6":"im"},{"3":"28bV-1648273017998","5":[{"2":"2","3":"R1p5-1648273017998","7":[{"8":"jdk 9中允许接口中定义私有的方法，但只能在本接口中调用"}]}]},{"3":"ddEx-1656388214159","5":[{"2":"2","3":"MN7p-1656388214158"}]},{"3":"rwPi-1647313139393","5":[{"2":"2","3":"Hawx-1647313139390","7":[{"8":"对象的销毁protect的方法：finalize(); 但只是暗示，并不保证一定发生"}]}]},{"3":"kdxX-1645087947507","4":{"l":"h2"},"5":[{"2":"2","3":"6Ce0-1645087947506","7":[{"8":"封装"}]}],"6":"h"},{"3":"bSOP-1645087947659","5":[{"2":"2","3":"327O-1645087947658","7":[{"8":"隐藏对象内部的复杂性，只对外暴露简单的接口，便于外界调用。提高系统的可拓展性，可维护性。","9":[{"0":18,"2":"fs"},{"0":"#F33232","2":"c"},{"2":"i"}]}]}]},{"3":"sR3V-1645088300644","4":{"l":"h3"},"5":[{"2":"2","3":"Wh4V-1645088300643","7":[{"8":"封装性的四种权限"}]}],"6":"h"},{"3":"Kcuo-1645088550220","4":{"version":1},"5":[{"2":"2","3":"7SOW-1645088550220","7":[{"8":"java权限修饰符置于类的成员定义前，用来限定对象对该类成员的访问权限"}]}]},{"3":"fKOI-1645088472405","4":{"version":1,"u":"https://note.youdao.com/yws/res/17095/WEBRESOURCE7663dae8f4794d2d7baa68d80e36e54b","w":627,"h":154},"6":"im"},{"3":"kTkI-1645088300969","5":[{"2":"2","3":"8gWI-1645088300969","7":[{"8":"","9":[{"0":18,"2":"fs"}]}]}]},{"3":"uTV5-1645088301096","4":{"l":"h2"},"5":[{"2":"2","3":"Sc0y-1645088301095","7":[{"8":"继承","9":[{"2":"b"}]}]}],"6":"h"},{"3":"5J8k-1646296065789","5":[{"2":"2","3":"D1ew-1646296065782","7":[{"8":"一旦子类继承了父类，子类就获取了父类中声明的所有的属性，方法。特别的，父类声明为私有的属性或方法，子类继承以后，依然认为获取了父类中私有的结构，只是因为封装性的影响，使子类不能直接调用父类的结构。","9":[{"0":18,"2":"fs"}]}]}]},{"3":"FUlt-1646297130352","4":{"l":"h3"},"5":[{"2":"2","3":"EczL-1646297130322","7":[{"8":"继承性的规定："}]}],"6":"h"},{"3":"7o6K-1646297572638","5":[{"2":"2","3":"ASF7-1646297572634","7":[{"8":"java只支持单继承和多层继承","9":[{"0":18,"2":"fs"}]}]}]},{"3":"KpkM-1646975162686","5":[{"2":"2","3":"aqLv-1646975162683","7":[{"8":"","9":[{"0":18,"2":"fs"}]}]}]},{"3":"SP5u-1646975162844","4":{"l":"h2"},"5":[{"2":"2","3":"XPnM-1646975162842","7":[{"8":"多态"}]}],"6":"h"},{"3":"mH4M-1646975163358","5":[{"2":"2","3":"bnmi-1646975163356","7":[{"8":"对象的多态性，父类的对象引用指向子类的对象","9":[{"0":18,"2":"fs"}]}]}]},{"3":"e2dC-1646975163436","5":[{"2":"2","3":"TOJf-1646975163434","7":[{"8":"对象的多态性，只适用于方法，不适用于属性(编","9":[{"0":18,"2":"fs"},{"0":"#F33232","2":"c"}]},{"8":"译","9":[{"0":18,"2":"fs"},{"0":"#F33232","2":"c"},{"2":"u"}]},{"8":"运行都看左边【父】)","9":[{"0":18,"2":"fs"},{"0":"#F33232","2":"c"}]},{"8":"调用方法默认子类，调用属性默认父类","9":[{"0":18,"2":"fs"},{"0":"#000000","2":"c"}]}]}]},{"3":"FTBV-1646296067849","5":[{"2":"2","3":"JWli-1646296067847","7":[{"8":"虚拟方法调用(多态情况下)：子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。——动态绑定"}]}]},{"3":"0qsx-1646296068063","5":[{"2":"2","3":"78t3-1646296068059","7":[{"8":"多态性声明为父类类型后，不能调用子类特有的方法，可以使用强制类型转换符转换成子类——向下转型","9":[{"0":18,"2":"fs"}]}]}]},{"3":"8Ief-1645088104926","5":[{"2":"2","3":"SIqu-1645088104926","7":[{"8":"","9":[{"0":18,"2":"fs"}]}]}]},{"3":"gcqt-1650172205977","4":{"l":"h2"},"5":[{"2":"2","3":"L0XK-1650172205975","7":[{"8":"内部类"}]}],"6":"h"},{"3":"YO2G-1650172200718","5":[{"2":"2","3":"Ojdd-1650172200715","7":[{"8":"局部内部类（方法内，代码块内，构造器内）","9":[{"0":18,"2":"fs"}]}]}]},{"3":"GKwX-1651651479202","5":[{"2":"2","3":"iEeN-1651651479199","7":[{"8":"成员内部类（静态，非静态）","9":[{"0":18,"2":"fs"}]},{"8":"类内可以定义属性、方法、构造器等。可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承。可以被abstract修饰。"}]}]},{"3":"q0ad-1651651759048","4":{"s":{"ti":28}},"5":[{"2":"2","3":"KrJF-1651651759042","7":[{"8":"作为成员内部类，可以调用外部类的结构。在局部内部类的方法中，如果调用局部内部类的方法中的局部变量的话，要求此局部变量为final"}]}]},{"3":"bk4K-1650172222318","5":[{"2":"2","3":"O9kQ-1650172222317","7":[{"8":"","9":[{"0":18,"2":"fs"}]}]}]}],"title":"","__compress__":true}