{"2":"1","3":"Ju9C-1621846617594","4":{"version":1,"incompatibleVersion":0,"fv":"0"},"5":[{"3":"3060-1621846615933","5":[{"2":"2","3":"p5PQ-1621846617594","7":[{"8":"MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"并发控制 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"。这项技术使得在InnoDB的事务隔离级别下执行 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"一致性读 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"kwlo-1659326865748","5":[{"2":"2","3":"7E7A-1659326865745","7":[{"8":"MVCC没有正式的标准，在不同的DBMS中MVCC的实现方式可能是不同的，也不是普遍使用的(大家可以参考相关的DBMS文档)。这里讲解InnoDB中MVCC的实现机制(MySQL其它的存储引擎并不支持它)"}]}]},{"3":"5xQg-1659335330309","4":{"l":"h1"},"5":[{"2":"2","3":"7HJP-1659335330308","7":[{"8":"快照读与当前读","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"MWHO-1659326866365","5":[{"2":"2","3":"pzzv-1659326866363","7":[{"8":"MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"读","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"-","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"写冲突 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"，做到即使有读写冲突时，也能做到 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"不加锁 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"， ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"非阻塞并发读 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"，而这个读指的就是 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"快照读 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":", 而非 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"当前读 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"gBsD-1659326866459","4":{"l":"h3"},"5":[{"2":"2","3":"8Vn6-1659326866458","7":[{"8":"快照读","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"rs42-1659326866552","5":[{"2":"2","3":"EiIL-1659326866551","7":[{"8":"快照读又叫一致性读，读取的是快照数据。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"不加锁的简单的 ","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"SELECT ","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"都属于快照读","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"，即不加锁的非阻塞读；比如这样：","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"OKnw-1659335440252","4":{"wrap":false,"la":"","th":"default"},"5":[{"3":"CzGE-1659335440251","5":[{"2":"2","3":"kyQI-1659326874389","7":[{"8":"SELECT * FROM player WHERE "}]}],"6":"cl"}],"6":"cd"},{"3":"wP2Z-1659326874897","5":[{"2":"2","3":"xdkk-1659326874895","7":[{"8":"之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下，避免了加锁操作，降低了开销。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"mTe3-1659335448742","4":{"version":1},"5":[{"2":"2","3":"OYGM-1659335448741","7":[{"8":"既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"G0ey-1659335448744","4":{"version":1},"5":[{"2":"2","3":"7Kas-1659335448743","7":[{"8":"快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"Jq7H-1659335789926","4":{"l":"h3"},"5":[{"2":"2","3":"tRZa-1659335789925","7":[{"8":"当前读","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"cJub-1659326875105","5":[{"2":"2","3":"Jppy-1659326875103","7":[{"8":"当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前读。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"RdX7-1659335854804","4":{"wrap":false,"la":"","th":"default"},"5":[{"3":"uJdm-1659335854803","5":[{"2":"2","3":"q5fW-1659326875198","7":[{"8":"SELECT * FROM student LOCK IN SHARE MODE; # 共享锁 "}]}],"6":"cl"},{"3":"XLYB-1659335855117","4":{},"5":[{"2":"2","3":"o6fz-1659335855116","7":[{"8":"SELECT * FROM student FOR UPDATE; # 排他锁 "}]}],"6":"cl"},{"3":"FrdH-1659335855119","4":{},"5":[{"2":"2","3":"2vnE-1659335855118","7":[{"8":"INSERT INTO student values ... # 排他锁 "}]}],"6":"cl"},{"3":"DA3n-1659335855121","4":{},"5":[{"2":"2","3":"8pKp-1659335855120","7":[{"8":"DELETE FROM student WHERE ... # 排他锁 "}]}],"6":"cl"},{"3":"Cf5j-1659335855123","4":{},"5":[{"2":"2","3":"64En-1659335855122","7":[{"8":"UPDATE student SET ... # 排他锁"}]}],"6":"cl"}],"6":"cd"},{"3":"7Rk7-1659326875310","4":{"l":"h3"},"5":[{"2":"2","3":"9cOC-1659326875309","7":[{"8":"隐藏字段、Undo Log版本链","9":[{"0":"#000000","2":"c"}]}]}],"6":"h"},{"3":"lfhz-1659336270200","5":[{"2":"2","3":"xDfg-1659336270199","7":[{"8":"回顾一下undo日志的版本链，对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。"}]}]},{"3":"BcVA-1659336270625","4":{"li":"GAX9-1659336285367","lt":"unordered","ll":1},"5":[{"2":"2","3":"Hw0r-1659336270624","7":[{"8":"trx_id:每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。"}]}],"6":"l"},{"3":"43gp-1659336281312","4":{"li":"GAX9-1659336285367","lt":"unordered","ll":1},"5":[{"2":"2","3":"9Zmr-1659336281311","7":[{"8":"roll_pointer:每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。"}]}],"6":"l"},{"3":"0mcC-1659326875404","5":[{"2":"2","3":"n9Kj-1659326875403","7":[{"8":"insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的Undo LogSegment也会被系统回收（也就是该undo日志占用的undo页面链表要么被重用，要么被释放)","9":[{"0":"#7B7B7B","2":"c"}]}]}]},{"3":"d2TY-1659326875501","4":{"l":"h1"},"5":[{"2":"2","3":"GFVc-1659326875499","7":[{"8":"MVCC","9":[{"0":"#34495e","2":"c"}]},{"8":"实现原理之","9":[{"2":"b"},{"0":"#34495e","2":"c"}]},{"8":"ReadView ","9":[{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"sbu6-1659326875612","5":[{"2":"2","3":"yyWQ-1659326875611","7":[{"8":"MVCC 的实现依赖于：","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"隐藏字段、","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"Undo Log","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"、","9":[{"2":"b"},{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"Read View","9":[{"0":"#880000","2":"c"},{"0":16,"2":"fs"}]},{"8":"。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"aK7j-1659326875707","4":{"l":"h3"},"5":[{"2":"2","3":"stXw-1659326875706","7":[{"8":"什么是","9":[{"2":"b"},{"0":"#34495e","2":"c"}]},{"8":"ReadView","9":[{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"v289-1659337005886","4":{"version":1},"5":[{"2":"2","3":"ggMh-1659337005887","7":[{"8":"在MVCC机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在Undo Log里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢?这时就需要用到ReadView了，它帮我们解决了行的可见性问题。"}]}]},{"3":"dTe4-1659337006061","4":{"version":1},"5":[{"2":"2","3":"9scS-1659337006060","7":[{"8":"ReadView就是事务在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前"},{"8":"活跃事务","9":[{"0":"#E96900FF","2":"c"}]},{"8":"的ID(“活跃\"指的就是，启动了但还没提交)。"}]}]},{"3":"hxlY-1659326875801","4":{"l":"h3"},"5":[{"2":"2","3":"UHny-1659326875800","7":[{"8":"设计思路","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"h03Z-1659326875913","5":[{"2":"2","3":"da8I-1659326875911","7":[{"8":"使用 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"READ UNCOMMITTED ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"LTDT-1659337205868","4":{"version":1},"5":[{"2":"2","3":"Anlh-1659337205867","7":[{"8":"使用 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"SERIALIZABLE ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"tw4N-1659337205870","4":{"version":1},"5":[{"2":"2","3":"xcd3-1659337205869","7":[{"8":"使用 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"READ COMMITTED ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"和 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"REPEATABLE READ ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"隔离级别的事务，都必须保证读到 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"已经提交了的 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"3HOU-1659336989020","5":[{"2":"2","3":"PbvP-1659336989019","7":[{"8":"这个ReadView中主要包含4个比较重要的内容，分别如下：","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"cg6q-1659336989526","5":[{"2":"2","3":"q9to-1659336989524","7":[{"8":"1. ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"creator_trx_id ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"，创建这个 Read View 的事务 ID。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"CWp3-1659337342826","4":{"version":1},"5":[{"2":"2","3":"IZoa-1659337342825","7":[{"8":"说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id（新分配的事务id越来越大），否则在一个只读事务中的事务id值都默认为0。 ","9":[{"0":"#777777","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"oU7w-1659337342830","4":{"version":1},"5":[{"2":"2","3":"gz0m-1659337342829","7":[{"8":"2. ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"trx_ids ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"，表示在生成ReadView时当前系统中活跃的读写事务的 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"事务","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"id","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"列表 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"。 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"arj1-1659337342832","4":{"version":1},"5":[{"2":"2","3":"cgOy-1659337342831","7":[{"8":"3. ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"up_limit_id ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"，活跃的事务中最小的事务 ID。 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"n5Gw-1659337342834","4":{"version":1},"5":[{"2":"2","3":"LV4l-1659337342833","7":[{"8":"4. ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"low_limit_id ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"，表示生成ReadView时系统中应该分配给下一个事务的 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"id ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"值。low_limit_id 是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"y2D2-1659337342839","4":{"version":1},"5":[{"2":"2","3":"jPg7-1659337342838","7":[{"8":"注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1， 2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。 ","9":[{"0":"#777777","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"QEsZ-1659338139269","4":{"l":"h3"},"5":[{"2":"2","3":"GaEf-1659338139268","7":[{"8":"ReadView","9":[{"0":"#34495e","2":"c"}]},{"8":"的规则","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"cfm7-1659336989733","5":[{"2":"2","3":"0wqA-1659336989732","7":[{"8":"有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"qWtI-1659338249032","4":{"version":1,"u":"https://note.youdao.com/yws/res/1/WEBRESOURCE7c315406ffadf5f5ed823b79434223e1","w":319,"h":180},"6":"im"},{"3":"P3x2-1659336989826","4":{"li":"3MNk-1659338158887","lt":"unordered","ll":1},"5":[{"2":"2","3":"oyRv-1659336989825","7":[{"8":"如果被访问版本的trx_id属性值与ReadView中的 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"creator_trx_id ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"hzEF-1659338150076","4":{"li":"3MNk-1659338158887","lt":"unordered","ll":1},"5":[{"2":"2","3":"VRaP-1659338150075","7":[{"8":"如果被访问版本的trx_id属性值小于ReadView中的 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"up_limit_id ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"aoxK-1659338150080","4":{"li":"3MNk-1659338158887","lt":"unordered","ll":1},"5":[{"2":"2","3":"y6Bh-1659338150079","7":[{"8":"如果被访问版本的trx_id属性值大于或等于ReadView中的 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"low_limit_id ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"48zl-1659338150084","4":{"li":"MJ7y-1659338176231","lt":"unordered","ll":1,"s":{"in":0}},"5":[{"2":"2","3":"BO0e-1659338150083","7":[{"8":"如果被访问版本的trx_id属性值在ReadView的 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"up_limit_id ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"和 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"low_limit_id ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"之间，那就需要判断一下trx_id属性值是不是在 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"trx_ids ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"列表中。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"RMpQ-1659336989940","4":{"li":"MJ7y-1659338176231","lt":"unordered","ll":2,"s":{"in":0}},"5":[{"2":"2","3":"cuQx-1659336989939","7":[{"8":"如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"D5iC-1659338170697","4":{"li":"MJ7y-1659338176231","lt":"unordered","ll":2,"s":{"in":0}},"5":[{"2":"2","3":"9XKR-1659338170696","7":[{"8":"如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"rsSw-1659338960832","4":{"l":"h3"},"5":[{"2":"2","3":"1a8y-1659338960831","7":[{"8":"MVCC","9":[{"0":"#34495e","2":"c"}]},{"8":"整体操作流程","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"gvxL-1659336990131","5":[{"2":"2","3":"49V4-1659336990130","7":[{"8":"了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过MVCC找到它：","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"JP1J-1659338967470","4":{"version":1},"5":[{"2":"2","3":"vsfT-1659338967469","7":[{"8":"1. 首先获取事务自己的版本号，也就是事务 ID； ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"zE3q-1659338967472","4":{"version":1},"5":[{"2":"2","3":"91yG-1659338967471","7":[{"8":"2. 获取 ReadView； ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"cglY-1659338967474","4":{"version":1},"5":[{"2":"2","3":"pTlH-1659338967473","7":[{"8":"3. 查询得到的数据，然后与 ReadView 中的事务版本号进行比较；","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"4IfC-1659338967476","4":{"version":1},"5":[{"2":"2","3":"K6Ma-1659338967475","7":[{"8":"4. 如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"9i57-1659338967478","4":{"version":1},"5":[{"2":"2","3":"fcYD-1659338967477","7":[{"8":"5. 最后返回符合规则的数据。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"zJ2w-1659338967481","4":{"version":1},"5":[{"2":"2","3":"vR8r-1659338967480","7":[{"8":"在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次Read View。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"Kliq-1659341959349","4":{"l":"h1"},"5":[{"2":"2","3":"G9m4-1659341959348","7":[{"8":"举例说明：","9":[{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"tRUm-1659341967065","4":{"version":1},"5":[{"2":"2","3":"tZGN-1659341967064"},{"2":"3","3":"g5oK-1659342061901","4":{"hf":"https://www.bilibili.com/video/BV1iq4y1u7vj?p=185&spm_id_from=pageDriver&vd_source=fe8bc72dda36d6577ba8e1f6f4870fae&t=2.2"},"5":[{"2":"2","3":"mzya-1659342061900","7":[{"8":"https://www.bilibili.com/video/BV1iq4y1u7vj?p=185&spm_id_from=pageDriver&vd_source=fe8bc72dda36d6577ba8e1f6f4870fae&t=2.2"}]}],"6":"li"},{"2":"2","3":"cRfK-1659342061910","7":[{"8":"","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"PVUD-1659336990228","4":{"l":"h1"},"5":[{"2":"2","3":"5pOG-1659336990227","7":[{"8":"总结","9":[{"2":"b"},{"0":"#34495e","2":"c"}]}]}],"6":"h"},{"3":"weFC-1659336990339","5":[{"2":"2","3":"hJmQ-1659336990338","7":[{"8":"这里介绍了 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"MVCC ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"在 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"READ COMMITTD ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"、 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"REPEATABLE READ ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"这两种隔离级别的事务在执行快照读操作时访问记录的版本链的过程。这样使不同事务的 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"读","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"-","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"写 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"、 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"写","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"-","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"读 ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"},{"0":"NSimSun","2":"ff"}]},{"8":"操作并发执行，从而提升系统性能。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"4ex6-1659341981285","4":{"version":1},"5":[{"2":"2","3":"g3zf-1659341981284","7":[{"8":"核心点在于 ReadView 的原理， ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"READ COMMITTD ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"、 ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]},{"8":"REPEATABLE READ ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"这两个隔离级别的一个很大不同就是生成ReadView的时机不同：","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}]},{"3":"ySvy-1659336990436","4":{"li":"czN4-1659341996244","lt":"unordered","ll":1},"5":[{"2":"2","3":"KCyM-1659336990434","7":[{"8":"READ COMMITTD ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"在每一次进行普通SELECT操作前都会生成一个ReadView ","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"T3D0-1659341991924","4":{"li":"czN4-1659341996244","lt":"unordered","ll":1},"5":[{"2":"2","3":"epvx-1659341991923","7":[{"8":"REPEATABLE READ ","9":[{"0":"#e96900","2":"c"},{"0":16,"2":"fs"}]},{"8":"只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。","9":[{"0":"#34495e","2":"c"},{"0":16,"2":"fs"}]}]}],"6":"l"},{"3":"hjrX-1659336990547","5":[{"2":"2","3":"sbJ7-1659336990545","7":[{"8":"说明:我们之前说执行DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除而是执行一个所谓的delete mark操作，相当于只是对记录打上了一个删除标志位，这主要就是为MVCc服务的。"}]}]},{"3":"Peep-1659336990644","5":[{"2":"2","3":"rTrf-1659336990643","7":[{"8":"通过MVCC 我们可以解决:"}]}]},{"3":"BJqn-1659342032781","4":{"version":1},"5":[{"2":"2","3":"Qmeh-1659342032780","7":[{"8":"1，读写之间阻塞的问题。通过MVCC可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。"}]}]},{"3":"DCVq-1659342032785","4":{"version":1},"5":[{"2":"2","3":"YhI8-1659342032784","7":[{"8":"2降低了死锁的概率。这是因为MVCC采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。"}]}]},{"3":"C5hV-1659342032789","4":{"version":1},"5":[{"2":"2","3":"et5l-1659342032788","7":[{"8":"3解决快照读的问题。当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。"}]}]}],"title":"","__compress__":true}