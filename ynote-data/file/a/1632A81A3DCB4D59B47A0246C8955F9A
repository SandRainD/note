<?xml version="1.0" encoding="UTF-8" standalone="no"?><note xmlns="http://note.youdao.com" file-version="0" schema-version="1.0.3"><head><list id="5011-1635848258253" type="unordered"/><list id="7600-1635848258253" type="unordered"/><list id="2440-1635848231188" type="unordered"/><list id="2795-1635848231189" type="unordered"/></head><body><para><coId>7079-1635509108538</coId><text>Redis 提供了2个不同形式的持久化方式。</text><inline-styles><font-family><from>0</from><to>6</to><value>Tahoma</value></font-family><font-family><from>6</from><to>9</to><value>微软雅黑</value></font-family><font-family><from>9</from><to>10</to><value>Times New Roman</value></font-family><font-family><from>10</from><to>22</to><value>微软雅黑</value></font-family></inline-styles><styles/></para><para><coId>7715-1635510775782</coId><text>l RDB（Redis DataBase）</text><inline-styles><font-family><from>2</from><to>5</to><value>Tahoma</value></font-family><font-family><from>5</from><to>6</to><value>微软雅黑</value></font-family><font-family><from>6</from><to>20</to><value>Times New Roman</value></font-family><font-family><from>20</from><to>21</to><value>微软雅黑</value></font-family></inline-styles><styles/></para><para><coId>7025-1635510775783</coId><text>l AOF（Append Of File）</text><inline-styles><font-family><from>2</from><to>5</to><value>Tahoma</value></font-family><font-family><from>5</from><to>6</to><value>微软雅黑</value></font-family><font-family><from>6</from><to>20</to><value>Times New Roman</value></font-family><font-family><from>20</from><to>21</to><value>微软雅黑</value></font-family></inline-styles><styles/></para><para><coId>1053-1635510790585</coId><text/><inline-styles/><styles/></para><para><coId>3466-1635510790727</coId><text>RDB在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</text><inline-styles><bold><from>224</from><to>246</to><value>true</value></bold><font-family><from>0</from><to>27</to><value>微软雅黑</value></font-family><font-family><from>35</from><to>43</to><value>Tahoma</value></font-family><font-family><from>43</from><to>63</to><value>微软雅黑</value></font-family><font-family><from>63</from><to>68</to><value>Tahoma</value></font-family><font-family><from>68</from><to>74</to><value>微软雅黑</value></font-family><font-family><from>74</from><to>78</to><value>Times New Roman</value></font-family><font-family><from>78</from><to>99</to><value>微软雅黑</value></font-family><font-family><from>102</from><to>139</to><value>微软雅黑</value></font-family><font-family><from>155</from><to>157</to><value>Tahoma</value></font-family><font-family><from>157</from><to>206</to><value>微软雅黑</value></font-family><font-family><from>206</from><to>209</to><value>Times New Roman</value></font-family><font-family><from>209</from><to>213</to><value>微软雅黑</value></font-family><font-family><from>213</from><to>216</to><value>Times New Roman</value></font-family><font-family><from>216</from><to>224</to><value>微软雅黑</value></font-family><font-family><from>224</from><to>227</to><value>Tahoma</value></font-family><font-family><from>227</from><to>247</to><value>微软雅黑</value></font-family><color><from>7</from><to>11</to><value>#ff0000</value></color><color><from>20</from><to>22</to><value>#ff0000</value></color><color><from>92</from><to>93</to><value>#ff0000</value></color><color><from>96</from><to>97</to><value>#ff0000</value></color><color><from>102</from><to>106</to><value>#ff0000</value></color><color><from>123</from><to>134</to><value>#ff0000</value></color><color><from>231</from><to>246</to><value>#ff0000</value></color></inline-styles><styles/></para><para><coId>7950-1635510851476</coId><text>l Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</text><inline-styles><font-family><from>2</from><to>6</to><value>Tahoma</value></font-family><font-family><from>6</from><to>49</to><value>微软雅黑</value></font-family><font-family><from>72</from><to>81</to><value>微软雅黑</value></font-family><color><from>19</from><to>24</to><value>#ff0000</value></color><color><from>72</from><to>81</to><value>#ff0000</value></color></inline-styles><styles/></para><para><coId>6348-1635510851831</coId><text>l 在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“写时复制技术”</text><inline-styles><bold><from>71</from><to>77</to><value>true</value></bold><font-family><from>2</from><to>3</to><value>微软雅黑</value></font-family><font-family><from>3</from><to>8</to><value>Tahoma</value></font-family><font-family><from>8</from><to>12</to><value>微软雅黑</value></font-family><font-family><from>12</from><to>18</to><value>Times New Roman</value></font-family><font-family><from>18</from><to>45</to><value>微软雅黑</value></font-family><font-family><from>45</from><to>49</to><value>Times New Roman</value></font-family><font-family><from>49</from><to>61</to><value>微软雅黑</value></font-family><font-family><from>61</from><to>66</to><value>Times New Roman</value></font-family><font-family><from>66</from><to>70</to><value>微软雅黑</value></font-family><font-family><from>71</from><to>78</to><value>微软雅黑</value></font-family><color><from>0</from><to>71</to><value>#007c6a</value></color><color><from>71</from><to>77</to><value>#ff0000</value></color><color><from>77</from><to>78</to><value>#007c6a</value></color></inline-styles><styles/></para><para><coId>1324-1635510851831</coId><text>l 一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</text><inline-styles><bold><from>0</from><to>23</to><value>true</value></bold><font-family><from>2</from><to>61</to><value>微软雅黑</value></font-family><color><from>0</from><to>61</to><value>#007c6a</value></color></inline-styles><styles/></para><para><coId>6020-1635510863014</coId><text>在redis.conf中配置文件名称，默认为dump.rdb</text><inline-styles><bold><from>0</from><to>30</to><value>true</value></bold><font-family><from>0</from><to>1</to><value>微软雅黑</value></font-family><font-family><from>1</from><to>11</to><value>Tahoma</value></font-family><font-family><from>11</from><to>22</to><value>微软雅黑</value></font-family><font-family><from>22</from><to>30</to><value>Times New Roman</value></font-family></inline-styles><styles/></para><para><coId>6777-1635510896701</coId><text>rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下</text><inline-styles><font-family><from>0</from><to>3</to><value>Tahoma</value></font-family><font-family><from>3</from><to>20</to><value>微软雅黑</value></font-family><font-family><from>20</from><to>25</to><value>Times New Roman</value></font-family><font-family><from>25</from><to>37</to><value>微软雅黑</value></font-family></inline-styles><styles/></para><para><coId>1335-1635510897061</coId><text>dir "/myredis/"</text><inline-styles><font-family><from>0</from><to>15</to><value>Tahoma</value></font-family></inline-styles><styles/></para><image><coId>5883-1635510897061</coId><source>https://note.youdao.com/yws/res/14252/E5E1F337727C47909FAC4F446EB2733B</source><text/><styles><align>justify</align><width>554</width><height>154</height></styles></image><para><coId>4411-1635510897061</coId><text> 配置文件中默认的快照配置</text><inline-styles><bold><from>1</from><to>13</to><value>true</value></bold><font-family><from>0</from><to>1</to><value>SimSun</value></font-family><font-family><from>1</from><to>13</to><value>宋体</value></font-family><font-size><from>1</from><to>13</to><value>18</value></font-size></inline-styles><styles><align>justify</align></styles></para><image><coId>1935-1635510913865</coId><source>https://note.youdao.com/yws/res/14254/5660112F97B24363B76C6A25B20506F3</source><text/><styles><width>554</width><height>174</height></styles></image><para><coId>9239-1635510913865</coId><text>命令save VS bgsave</text><inline-styles><bold><from>0</from><to>16</to><value>true</value></bold><font-family><from>0</from><to>2</to><value>宋体</value></font-family><font-family><from>2</from><to>16</to><value>Calibri Light</value></font-family><font-size><from>0</from><to>16</to><value>18</value></font-size></inline-styles><styles><align>justify</align></styles></para><para><coId>7225-1635510924538</coId><text>save ：save时只管保存，其它不管，全部阻塞。手动保存。不建议。</text><inline-styles><font-family><from>0</from><to>5</to><value>Tahoma</value></font-family><font-family><from>5</from><to>6</to><value>微软雅黑</value></font-family><font-family><from>6</from><to>10</to><value>Times New Roman</value></font-family><font-family><from>10</from><to>35</to><value>微软雅黑</value></font-family></inline-styles><styles/></para><para><coId>8595-1635510924538</coId><text>bgsave：Redis会在后台异步进行快照操作， 快照同时还可以响应客户端请求。</text><inline-styles><bold><from>0</from><to>41</to><value>true</value></bold><font-family><from>0</from><to>6</to><value>Tahoma</value></font-family><font-family><from>6</from><to>7</to><value>微软雅黑</value></font-family><font-family><from>7</from><to>12</to><value>Times New Roman</value></font-family><font-family><from>12</from><to>25</to><value>微软雅黑</value></font-family><color><from>0</from><to>41</to><value>#ff0000</value></color></inline-styles><styles/></para><para><coId>7789-1635510924538</coId><text>可以通过lastsave 命令获取最后一次成功执行快照的时间</text><inline-styles><font-family><from>0</from><to>4</to><value>微软雅黑</value></font-family><font-family><from>4</from><to>13</to><value>Tahoma</value></font-family><font-family><from>13</from><to>30</to><value>微软雅黑</value></font-family></inline-styles><styles/></para><para><coId>9030-1635510952388</coId><text>flushall命令</text><inline-styles><bold><from>0</from><to>10</to><value>true</value></bold><font-family><from>0</from><to>8</to><value>Calibri Light</value></font-family><font-family><from>8</from><to>10</to><value>宋体</value></font-family><font-size><from>0</from><to>10</to><value>18</value></font-size></inline-styles><styles><align>justify</align></styles></para><para><coId>5272-1635510952721</coId><text>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</text><inline-styles><font-family><from>0</from><to>2</to><value>微软雅黑</value></font-family><font-family><from>2</from><to>10</to><value>Tahoma</value></font-family><font-family><from>10</from><to>17</to><value>微软雅黑</value></font-family><font-family><from>17</from><to>25</to><value>Times New Roman</value></font-family><font-family><from>25</from><to>38</to><value>微软雅黑</value></font-family></inline-styles><styles/></para><para><coId>1146-1635511167657</coId><text>动态停止RDB：redis-cli config set save ""#save后给空值，表示禁用保存策略</text><inline-styles><font-family><from>0</from><to>4</to><value>微软雅黑</value></font-family><font-family><from>4</from><to>7</to><value>Tahoma</value></font-family><font-family><from>7</from><to>8</to><value>微软雅黑</value></font-family><font-family><from>8</from><to>25</to><value>Times New Roman</value></font-family><font-family><from>25</from><to>41</to><value>Tahoma</value></font-family><font-family><from>41</from><to>54</to><value>微软雅黑</value></font-family></inline-styles><styles/></para><para><coId>3457-1635511093890</coId><text/><inline-styles/><styles/></para><para><coId>6654-1635511094052</coId><text/><inline-styles/><styles/></para><para><coId>5010-1635511094227</coId><text/><inline-styles/><styles/></para><para><coId>5470-1635511094733</coId><text>stop-writes-on-bgsave-error</text><inline-styles><bold><from>0</from><to>27</to><value>true</value></bold><font-family><from>0</from><to>27</to><value>Calibri Light</value></font-family><font-size><from>0</from><to>27</to><value>18</value></font-size></inline-styles><styles><align>justify</align></styles></para><image><coId>7625-1635511096052</coId><source>https://note.youdao.com/yws/res/14258/72CA926EAAB44EB694BFBA5B7406EFBA</source><text/><styles><width>554</width><height>102</height></styles></image><para><coId>5973-1635511096052</coId><text> </text><inline-styles><font-family><from>0</from><to>1</to><value>SimSun</value></font-family></inline-styles><styles/></para><para><coId>2965-1635511096052</coId><text>当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes.</text><inline-styles><font-family><from>0</from><to>1</to><value>微软雅黑</value></font-family><font-family><from>1</from><to>6</to><value>Tahoma</value></font-family><font-family><from>6</from><to>19</to><value>微软雅黑</value></font-family><font-family><from>19</from><to>24</to><value>Times New Roman</value></font-family><font-family><from>24</from><to>31</to><value>微软雅黑</value></font-family></inline-styles><styles/></para><para><coId>1482-1635511110667</coId><text>rdbcompression 压缩文件</text><inline-styles><bold><from>0</from><to>19</to><value>true</value></bold><font-family><from>0</from><to>15</to><value>Calibri Light</value></font-family><font-family><from>15</from><to>19</to><value>宋体</value></font-family><font-size><from>0</from><to>19</to><value>18</value></font-size></inline-styles><styles><align>justify</align></styles></para><image><coId>7186-1635511111034</coId><source>https://note.youdao.com/yws/res/14260/392D8F9915A3417492300FFDB7B9CBB5</source><text/><styles><width>554</width><height>99</height></styles></image><para><coId>1598-1635511111034</coId><text> </text><inline-styles><font-family><from>0</from><to>1</to><value>SimSun</value></font-family></inline-styles><styles/></para><para><coId>7553-1635511111034</coId><text>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。</text><inline-styles><font-family><from>0</from><to>31</to><value>微软雅黑</value></font-family><font-family><from>31</from><to>36</to><value>Tahoma</value></font-family><font-family><from>36</from><to>39</to><value>微软雅黑</value></font-family><font-family><from>39</from><to>42</to><value>Tahoma</value></font-family><font-family><from>42</from><to>49</to><value>微软雅黑</value></font-family><color><from>39</from><to>44</to><value>#ff0000</value></color></inline-styles><styles/></para><para><coId>2886-1635511111034</coId><text>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes.</text><inline-styles><font-family><from>0</from><to>7</to><value>微软雅黑</value></font-family><font-family><from>7</from><to>10</to><value>Tahoma</value></font-family><font-family><from>10</from><to>31</to><value>微软雅黑</value></font-family></inline-styles><styles/></para><para><coId>5447-1635511125951</coId><text>rdb的备份</text><inline-styles><bold><from>0</from><to>6</to><value>true</value></bold><font-family><from>0</from><to>3</to><value>Calibri Light</value></font-family><font-family><from>3</from><to>6</to><value>宋体</value></font-family><font-size><from>0</from><to>6</to><value>18</value></font-size></inline-styles><styles><align>justify</align></styles></para><para><coId>2968-1635511126258</coId><text>先通过config get dir  查询rdb文件的目录</text><inline-styles><font-family><from>0</from><to>3</to><value>微软雅黑</value></font-family><font-family><from>3</from><to>19</to><value>Tahoma</value></font-family><font-family><from>19</from><to>21</to><value>微软雅黑</value></font-family><font-family><from>21</from><to>24</to><value>Times New Roman</value></font-family><font-family><from>24</from><to>29</to><value>微软雅黑</value></font-family></inline-styles><styles/></para><para><coId>3815-1635511126258</coId><text>将*.rdb的文件拷贝到别的地方</text><inline-styles><font-family><from>0</from><to>1</to><value>微软雅黑</value></font-family><font-family><from>1</from><to>6</to><value>Tahoma</value></font-family><font-family><from>6</from><to>16</to><value>微软雅黑</value></font-family></inline-styles><styles/></para><para><coId>3388-1635511126258</coId><text>rdb的恢复</text><inline-styles><font-family><from>0</from><to>3</to><value>Tahoma</value></font-family><font-family><from>3</from><to>6</to><value>微软雅黑</value></font-family></inline-styles><styles/></para><para><coId>6899-1635511126258</coId><text>u 关闭Redis</text><inline-styles><font-family><from>2</from><to>4</to><value>微软雅黑</value></font-family><font-family><from>4</from><to>9</to><value>Tahoma</value></font-family></inline-styles><styles/></para><para><coId>3687-1635511126258</coId><text>u 先把备份的文件拷贝到工作目录下 cp dump2.rdb dump.rdb</text><inline-styles><font-family><from>2</from><to>17</to><value>微软雅黑</value></font-family><font-family><from>18</from><to>25</to><value>Tahoma</value></font-family><font-family><from>26</from><to>39</to><value>Tahoma</value></font-family></inline-styles><styles/></para><para><coId>4250-1635511126258</coId><text>u 启动Redis, 备份数据会直接加载</text><inline-styles><font-family><from>2</from><to>4</to><value>微软雅黑</value></font-family><font-family><from>4</from><to>11</to><value>Tahoma</value></font-family><font-family><from>11</from><to>20</to><value>微软雅黑</value></font-family></inline-styles><styles/></para><para><coId>2255-1635512174382</coId><text/><inline-styles/><styles/></para><para><coId>9898-1635512175401</coId><text/><inline-styles/><styles/></para><para><coId>2862-1635512175633</coId><text>--------------------------------------------------------------------------------</text><inline-styles><font-family><from>0</from><to>80</to><value>微软雅黑</value></font-family></inline-styles><styles/></para><heading compat="true" level="a"><coId>6361-1635512180751</coId><text>AOF </text><inline-styles><bold><from>0</from><to>4</to><value>true</value></bold><font-family><from>0</from><to>4</to><value>微软雅黑</value></font-family><font-size><from>0</from><to>4</to><value>32</value></font-size></inline-styles><styles/></heading><para><coId>2689-1635512212167</coId><text>以日志的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(读操作不记录)， 只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</text><inline-styles><bold><from>1</from><to>3</to><value>true</value></bold><bold><from>41</from><to>47</to><value>true</value></bold><bold><from>50</from><to>64</to><value>true</value></bold><font-family><from>40</from><to>41</to><value>Times New Roman</value></font-family><font-family><from>91</from><to>97</to><value>Times New Roman</value></font-family><color><from>0</from><to>21</to><value>#ff0000</value></color><color><from>41</from><to>47</to><value>#ff0000</value></color><color><from>50</from><to>64</to><value>#ff0000</value></color></inline-styles><styles/></para><para><coId>3552-1635512185030</coId><text>（1）客户端的请求写命令会被append追加到AOF缓冲区内；</text><inline-styles/><styles/></para><para><coId>2384-1635847843261</coId><text>（2）AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；</text><inline-styles/><styles/></para><para><coId>1766-1635847843261</coId><text>（3）AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；</text><inline-styles><font-size><from>30</from><to>38</to><value>16</value></font-size></inline-styles><styles/></para><para><coId>5999-1635847843261</coId><text>（4）Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的；</text><inline-styles/><styles/></para><para><coId>6972-1635847884883</coId><text>AOF默认不开启</text><inline-styles><bold><from>0</from><to>8</to><value>true</value></bold><font-family><from>0</from><to>8</to><value>SimSun</value></font-family><font-size><from>0</from><to>8</to><value>21</value></font-size></inline-styles><styles/></para><para><coId>4190-1635847881501</coId><text>可以在redis.conf中配置文件名称，默认为 appendonly.aof，修改appendonly no 为yes</text><inline-styles><color><from>25</from><to>60</to><value>#ff0000</value></color></inline-styles><styles/></para><para><coId>9099-1635847881501</coId><text>AOF文件的保存路径，同RDB的路径一致。</text><inline-styles><font-family><from>12</from><to>15</to><value>Times New Roman</value></font-family></inline-styles><styles/></para><para><coId>7995-1635847622966</coId><text>AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）</text><inline-styles/><styles/></para><list-item level="1" list-id="5011-1635848258253"><coId>6477-1635848258255</coId><text>正常恢复</text><inline-styles/><styles/></list-item><list-item level="1" list-id="7600-1635848258253"><coId>4977-1635848258255</coId><text>修改默认的appendonly no，改为yes</text><inline-styles/><styles/></list-item><list-item level="1" list-id="7600-1635848258253"><coId>1518-1635848258255</coId><text>将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir)</text><inline-styles/><styles/></list-item><list-item level="1" list-id="7600-1635848258253"><coId>8235-1635848258255</coId><text>恢复：重启redis然后重新加载</text><inline-styles/><styles/></list-item><para><coId>7451-1635848262098</coId><text/><inline-styles/><styles/></para><list-item level="1" list-id="2440-1635848231188"><coId>3991-1635848231201</coId><text>异常恢复，非正常结束运行文件损坏等等</text><inline-styles/><styles/></list-item><list-item level="1" list-id="2795-1635848231189"><coId>3365-1635848231201</coId><text>修改默认的appendonly no，改为yes</text><inline-styles><font-family><from>21</from><to>24</to><value>Times New Roman</value></font-family></inline-styles><styles/></list-item><list-item level="1" list-id="2795-1635848231189"><coId>6064-1635848231201</coId><text>如遇到AOF文件损坏，通过/usr/local/bin/redis-check-aof--fix appendonly.aof进行恢复</text><inline-styles><bold><from>3</from><to>10</to><value>true</value></bold><bold><from>28</from><to>63</to><value>true</value></bold><color><from>3</from><to>10</to><value>#ff0000</value></color><color><from>28</from><to>63</to><value>#ff0000</value></color></inline-styles><styles/></list-item><list-item level="1" list-id="2795-1635848231189"><coId>8680-1635848231201</coId><text>备份被写坏的AOF文件</text><inline-styles/><styles/></list-item><list-item level="1" list-id="2795-1635848231189"><coId>2935-1635848231201</coId><text>恢复：重启redis，然后重新加载</text><inline-styles/><styles/></list-item><para><coId>0082-1635847623575</coId><text> AOF同步频率设置</text><inline-styles><bold><from>1</from><to>10</to><value>true</value></bold><font-family><from>0</from><to>1</to><value>Times New Roman</value></font-family><font-family><from>1</from><to>10</to><value>SimSun</value></font-family><font-size><from>0</from><to>1</to><value>9</value></font-size><font-size><from>1</from><to>10</to><value>21</value></font-size></inline-styles><styles><align>justify</align></styles></para><para><coId>7026-1635848565742</coId><text>appendfsync always</text><inline-styles/><styles/></para><para><coId>2030-1635848565742</coId><text>始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好</text><inline-styles><color><from>0</from><to>24</to><value>#007c6a</value></color></inline-styles><styles/></para><para><coId>5097-1635848565742</coId><text>appendfsync everysec</text><inline-styles><color><from>12</from><to>20</to><value>#ff0000</value></color></inline-styles><styles/></para><para><coId>6160-1635848565742</coId><text>每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</text><inline-styles><color><from>0</from><to>29</to><value>#007c6a</value></color></inline-styles><styles/></para><para><coId>8852-1635848565742</coId><text>appendfsync no</text><inline-styles/><styles/></para><para><coId>5346-1635848565742</coId><text>redis不主动进行同步，把同步时机交给操作系统。</text><inline-styles><color><from>0</from><to>14</to><value>#007c6a</value></color><color><from>14</from><to>24</to><value>#ff0000</value></color><color><from>24</from><to>25</to><value>#007c6a</value></color></inline-styles><styles/></para><para><coId>2274-1635847623608</coId><text/><inline-styles/><styles/></para><para><coId>7370-1635847623639</coId><text> Rewrite压缩</text><inline-styles><bold><from>1</from><to>10</to><value>true</value></bold><font-family><from>0</from><to>1</to><value>Times New Roman</value></font-family><font-family><from>1</from><to>10</to><value>SimSun</value></font-family><font-size><from>0</from><to>1</to><value>9</value></font-size><font-size><from>1</from><to>10</to><value>21</value></font-size></inline-styles><styles><align>justify</align></styles></para><para><coId>5151-1635848674430</coId><text>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof</text><inline-styles/><styles/></para><para><coId>6234-1635848674430</coId><text>2重写原理，如何实现重写</text><inline-styles/><styles/></para><para><coId>6865-1635848674430</coId><text>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，实质上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。</text><inline-styles><color><from>51</from><to>119</to><value>#ff0000</value></color></inline-styles><styles/></para><para><coId>4065-1635848674430</coId><text>no-appendfsync-on-rewrite：</text><inline-styles><color><from>0</from><to>26</to><value>#ff0000</value></color></inline-styles><styles/></para><para><coId>8316-1635848674430</coId><text>如果 no-appendfsync-on-rewrite=yes ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）</text><inline-styles/><styles/></para><para><coId>1298-1635847623669</coId><text>如果 no-appendfsync-on-rewrite=no,  还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</text><inline-styles/><styles/></para><para><coId>8098-1635848762985</coId><text>触发机制，何时重写</text><inline-styles/><styles/></para><para><coId>8177-1635847623701</coId><text>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</text><inline-styles/><styles/></para><para><coId>9786-1635848815592</coId><text>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。</text><inline-styles><color><from>0</from><to>61</to><value>#00b050</value></color></inline-styles><styles/></para><para><coId>2891-1635848815592</coId><text>auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）</text><inline-styles/><styles/></para><para><coId>5110-1635848815592</coId><text>auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。</text><inline-styles/><styles/></para><para><coId>4719-1635848863211</coId><text>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB</text><inline-styles/><styles/></para><para><coId>1935-1635848863539</coId><text>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,</text><inline-styles/><styles/></para><para><coId>7548-1635848863539</coId><text>如果Redis的AOF当前大小&gt;= base_size +base_size*100% (默认)且当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行重写。</text><inline-styles><color><from>8</from><to>44</to><value>#ff0000</value></color><color><from>49</from><to>59</to><value>#ff0000</value></color></inline-styles><styles/></para><para><coId>4010-1635848876178</coId><text>重写流程</text><inline-styles/><styles/></para><para><coId>4343-1635848876512</coId><text>（1）bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。</text><inline-styles/><styles/></para><para><coId>2841-1635848876512</coId><text>（2）主进程fork出子进程执行重写操作，保证主进程不会阻塞。</text><inline-styles/><styles/></para><para><coId>2374-1635848876512</coId><text>（3）子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。</text><inline-styles/><styles/></para><para><coId>2615-1635848876512</coId><text>（4）1).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。2).主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</text><inline-styles/><styles/></para><para><coId>4971-1635848876512</coId><text>（5）使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</text><inline-styles/><styles/></para></body></note>